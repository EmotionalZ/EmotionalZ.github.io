<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="ZYX_Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="ZYX&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="ZYX&#39;s Blog">
<meta property="og:description" content="ZYX_Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhao Yi Xiao">
<meta property="article:tag" content="zhao Blog">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZYX's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZYX's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Nothing Seek, Nothing Find</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhao Yi Xiao</p>
  <div class="site-description" itemprop="description">ZYX_Blog</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/31/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhao Yi Xiao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYX's Blog">
      <meta itemprop="description" content="ZYX_Blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZYX's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/31/Spring/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-31 23:01:31" itemprop="dateCreated datePublished" datetime="2023-07-31T23:01:31+08:00">2023-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-09 12:53:09" itemprop="dateModified" datetime="2023-08-09T12:53:09+08:00">2023-08-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="🥬Spring"><a href="#🥬Spring" class="headerlink" title="🥬Spring"></a>🥬Spring</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>设计模式是软件设计中常见问题的可重用解决方案。它代表了最佳的实践,通常被有经验的面向对象的软件开发人员所采用。设计模式通过提高代码的可重用性、代码间的耦合度降低、程序的可靠性提高等优点,使程序的开发效率和质量得到提高。</p>
<!-- show more-->

<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ol>
<li>单一职责原则 - 一个类只做该做的一件事。</li>
<li>开闭原则 - 软件实体应对扩展开放,对修改关闭。</li>
<li>里氏替换原则 - 任何基类可以出现的地方子类一定可以出现。</li>
<li>依赖倒转原则 - 要依赖于抽象,不要依赖于具体。</li>
<li>接口隔离原则 - 使用多个专门的接口比使用单个总接口好。</li>
<li>迪米特法则 - 一个软件实体应当尽可能少地与其他实体发生相互作用。</li>
</ol>
<h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><blockquote>
<p>用于处理对象的创建,在不修改原有系统的前提下,控制对象的创建过程。</p>
</blockquote>
<h5 id="单例模式-系统中一个类只能存在一个对象实例。"><a href="#单例模式-系统中一个类只能存在一个对象实例。" class="headerlink" title="单例模式 - 系统中一个类只能存在一个对象实例。"></a>单例模式 - 系统中一个类只能存在一个对象实例。</h5><p>7种实现：</p>
<p>最完美：枚举、双重检查</p>
<ul>
<li>工厂方法模式 - 定义一个用于创建对象的接口,让子类决定实例化哪一个类。</li>
<li>抽象工厂模式 - 提供一个创建一系列相关或相互依赖对象的接口。</li>
<li>建造者模式 - 使用多个简单的对象一步一步构建成一个复杂的对象。</li>
<li>原型模式 - 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象。</li>
</ul>
<h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><p>关注类和对象的组合。它们用于描述如何将类或对象按某种布局组成更大的结构。</p>
<ul>
<li>适配器模式 - 转换一个类的接口以满足用户需求。</li>
<li>桥接模式 - 将抽象与实现分离,使它们可以独立变化。</li>
<li>组合模式 - 组合对象包含子部件对象,用来表示部分与整体层次。</li>
<li>装饰器模式 - 动态地给一个对象增加一些额外的职责。</li>
<li>外观模式 - 为子系统中的一组接口提供一个统一的高层接口。</li>
<li>享元模式 - 使用共享对象可有效地支持大量细粒度的对象。</li>
<li>代理模式 - 使用代理对象来控制对其他对象的访问。</li>
</ul>
<h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><p>关注对象之间的通信。</p>
<ul>
<li>命令模式 - 将一个请求封装成一个对象,以便使用不同的请求对客户进行参数化。</li>
<li>迭代器模式 - 提供一个方法顺序访问一个聚合对象中的各个元素。</li>
<li>观察者模式 - 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知。</li>
<li>中介者模式 - 用一个中介对象来封装一系列的对象交互,中介者使各对象不需要显式地相互引用。</li>
<li>备忘录模式 - 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。</li>
<li>状态模式 - 当一个对象内在状态改变时允许其改变行为,这个对象看起来像是改变了其类。</li>
<li>策略模式 - 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</li>
<li>模板方法模式 - 定义一个操作中的算法的骨架,而将一些步骤延迟到子类中。</li>
<li>访问者模式 - 封装一些作用于某种数据结构中的各元素的操作,它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</li>
</ul>
<h3 id="使用设计模式改进开发"><a href="#使用设计模式改进开发" class="headerlink" title="使用设计模式改进开发"></a>使用设计模式改进开发</h3><p>Java EE开发中可以在以下几个方面使用设计模式进行优化:</p>
<ol>
<li>数据访问层 - 使用DAO模式将数据访问操作抽象化,例如使用Spring JdbcTemplate实现DAO。</li>
<li>业务层 - 使用业务代表(Business Delegate)模式封装业务服务,降低业务层和其他层的耦合。使用业务对象(Business Object)模式封装业务逻辑。</li>
<li>Web层 - 使用MVC模式解耦控制器、模型和视图。使用前端控制器(Front Controller)模式实现请求的统一分发。</li>
<li>权限控制 - 使用代理(Proxy)模式和装饰(Decorator)模式实现权限控制和额外功能扩展。</li>
<li>配置管理 - 使用依赖注入(DI)模式实现配置的动态注入。</li>
<li>异步处理 - 使用观察者(Observer)模式实现异步事件处理、监听器。</li>
<li>会话管理 - 使用策略(Strategy)模式封装不同的会话管理实现。</li>
<li>缓存 - 使用享元(Flyweight)模式优化内存占用。</li>
</ol>
<p>常用的设计模式包括:DAO、MVC、代理、观察者、单例、工厂等。使用合适的设计模式可以提高代码灵活性和可维护性。但也需要根据实际情况确定,过度使用设计模式会增加系统的复杂性。</p>
<h3 id="数据库，持久层，dao"><a href="#数据库，持久层，dao" class="headerlink" title="数据库，持久层，dao"></a>数据库，持久层，dao</h3><h3 id="代理（动态）"><a href="#代理（动态）" class="headerlink" title="代理（动态）"></a>代理（动态）</h3><blockquote>
<p>Thread接收实现Runnable接口的实现类和代理Proxy接收InvocationHandler接口的实现类,二者之间确实有一些相似之处:</p>
<ol>
<li>都定义了一个接口,用于接收执行逻辑的实现对象。</li>
</ol>
<ul>
<li>Runnable接口:定义了run()方法</li>
<li>InvocationHandler接口:定义了invoke()方法</li>
</ul>
<ol start="2">
<li>都由一个主类负责处理调用调度工作。</li>
</ol>
<ul>
<li>Thread类:调用Runnable的run()方法</li>
<li>Proxy类:调用InvocationHandler的invoke()方法</li>
</ul>
<ol start="3">
<li>Runnable和InvocationHandler可以理解为策略角色。</li>
</ol>
<ul>
<li>封装可替换的执行逻辑</li>
<li>Thread和Proxy作为上下文调用它们</li>
</ul>
<ol start="4">
<li>都可以起到解耦的作用。</li>
</ol>
<ul>
<li>Thread和Runnable解耦线程模型和任务逻辑</li>
<li>Proxy和InvocationHandler解耦调用方和处理逻辑</li>
</ul>
<ol start="5">
<li>都能扩展功能。</li>
</ol>
<ul>
<li>Runnable扩展Thread的执行能力</li>
<li>InvocationHandler扩展Proxy的代理能力</li>
</ul>
<p>所以从接口定义、执行调度、解耦关注点等方面来看,两者尽管目的不同,但作为一种设计模式其思想是相通的,都起到了扩展原有功能的作用。</p>
</blockquote>
<h4 id="动态代理思路"><a href="#动态代理思路" class="headerlink" title="动态代理思路"></a>动态代理思路</h4><p>生成ProxyHandler和代理类（为了：</p>
<ol>
<li>职责清晰：代理类负责 解析并生成被代理类；Handler负责方法重构</li>
<li>解耦合 - 任意InvocationHandler可以与任意接口结合使用。</li>
<li>复用性 - 一个InvocationHandler可以复用到多个接口实现类。</li>
<li>灵活性 - 可以动态替换InvocationHandler来改变代理逻辑。</li>
</ol>
<p>）</p>
<h4 id="静态代理、动态代理"><a href="#静态代理、动态代理" class="headerlink" title="静态代理、动态代理"></a>静态代理、动态代理</h4><blockquote>
<p>区别在于静态需要接口，需要在构造函数中传入确定的类型（实现了同个接口的“兄弟类”）；动态接口利用Proxy反射实现了在构造函数中写的是接口类型（也就意味着可以随便传入接口类型的什么类），</p>
<p><strong>重点：</strong>InvocationHandler中重写的方法：invoke：</p>
<ol>
<li><p>传的参数可以这么理解:</p>
<ul>
<li><p>proxy - 代理类实例</p>
</li>
<li><p>method - 正在调用的接口方法的Method实例</p>
</li>
<li><p>args - 调用接口方法时传入的参数</p>
</li>
</ul>
</li>
<li><p>在动态代理第四步中当调用代理类的方法时,会被转发到InvocationHandler.invoke方法中,传入代理类实例、方法相关信息、方法参数。</p>
</li>
</ol>
</blockquote>
<p>动态第三步VS静态第三步</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230728214822367.png" alt="image-20230728214822367"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230728214929515.png" alt="image-20230728214929515"></p>
<p>动态第四步VS静态第四步</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230728221707382.png" alt="image-20230728221707382"></p>
<blockquote>
<p>第二、第三步的内部流程：Proxy的代理</p>
<ol>
<li>Proxy类的newProxyInstance方法被调用,创建代理对象。</li>
<li>newProxyInstance内部通过ProxyClassFactory生成了一个实现了接口的代理类<code>realProxySubject</code></li>
<li>代理类继承了Proxy,重写了hof方法,hof内部实现了反射调用InvocationHandler.invoke。</li>
<li>将传入的InvocationHandler设置为代理类的h属性。</li>
<li>返回这个动态生成的代理类的实例作为代理对象。</li>
</ol>
<hr>
<ol>
<li>当调用代理对象方法时,会调用hof,然后反射调用InvocationHandler.invoke。</li>
<li>invoke方法中可以实现自定义代理逻辑。</li>
<li>invoke最后会通过反射调用目标对象的实际方法。</li>
<li>目标方法执行后,返回结果返回给调用者。</li>
</ol>
<hr>
<p>其中，在JDK动态代理的实现里,hof是代理类中一个重要的方法。</p>
<p>hof全称是handOff,中文意思是交接、移交。它是一个protected方法,定义在Proxy类中,签名如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">h</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure>

<p>Proxy类生成的代理类会继承Proxy,并重写这个hof方法。</p>
<p>当通过代理对象调用方法时,会调用hof,hof内部使用反射调用InvocationHandler的invoke方法,传入代理实例、方法和参数。</p>
<p>hof的具体逻辑是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">h</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> invocationHandler.invoke(proxy, method, args);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以hof起到一个移交的作用,将对代理对象的方法调用移交给InvocationHandler的invoke方法进行处理。</p>
<p>hof封装了反射调用和异常处理的细节,简化了代理类的代码。</p>
<p>这样代理类就可以集中精力对invoke返回的结果做后续处理。</p>
<p>所以hof是一个连接代理类和InvocationHandler的重要桥梁。</p>
</blockquote>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230728215739724.png" alt="image-20230728215739724"></p>
<h3 id="⭐注解！！"><a href="#⭐注解！！" class="headerlink" title="⭐注解！！"></a>⭐注解！！</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804085611210.png" alt="image-20230804085611210"></p>
<p>注解默认在编译期消失</p>
<p>注解成员：</p>
<ul>
<li>枚举、常量、基本数据类型、Class</li>
</ul>
<p>Class玩法较多：可定义接口，lambda接口：</p>
<ol>
<li>根据不同的入参进行转换<ol>
<li>切面中需要从自定义注解中拿参数——》</li>
<li>自定义注解中的参数：可以是一个Lambda接口</li>
<li>接口使用泛型规定一个参数param——》</li>
<li>实现接口，根据不同的对象传入返回不同的参数</li>
<li></li>
</ol>
</li>
</ol>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><blockquote>
<p>注解：可以在任意地方添加元信息</p>
<p>反射：可以得到注解的信息</p>
<p>反射操作注解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(<span class="string">&quot;reflection.Customer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射获取注解</span></span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation:annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取注解的值</span></span><br><span class="line">        <span class="type">TableAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> c1.getAnnotation(TableAnnotation.class);</span><br><span class="line">        System.out.println(annotation.value());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类指定注解</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">FiledAnnotation</span> <span class="variable">annotation1</span> <span class="operator">=</span> id.getAnnotation(FiledAnnotation.class);</span><br><span class="line">        System.out.println(annotation1.columnName());</span><br><span class="line">        System.out.println(annotation1.length());</span><br><span class="line">        System.out.println(annotation1.type());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> TableAnnotation&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableAnnotation(&quot;db_customer&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FiledAnnotation(columnName=&quot;id&quot;,type = &quot;Long&quot;,length =10)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FiledAnnotation(columnName=&quot;age&quot;,type = &quot;int&quot;,length =10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FiledAnnotation(columnName=&quot;name&quot;,type = &quot;String&quot;,length =10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> FiledAnnotation&#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">type</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><ol>
<li>流程：<ol>
<li>通过MybatisUtil获取SqlSession</li>
<li>获取对应domain类的Mapper（连接数据库进行SQL操作）</li>
<li>（查询）获取Example domain类，加入查询条件</li>
<li>返回对应返回值（domain类或者int值）</li>
<li>Session commit&#x2F;close</li>
</ol>
</li>
</ol>
<h3 id="Jar-War包运行"><a href="#Jar-War包运行" class="headerlink" title="Jar&amp;War包运行"></a>Jar&amp;War包运行</h3><p>war包放入tomcat，jar包</p>
<h2 id="🥬IOC-DI"><a href="#🥬IOC-DI" class="headerlink" title="🥬IOC&#x2F;DI"></a>🥬IOC&#x2F;DI</h2><p>是什么：</p>
<ol>
<li>解耦：方便滴更改Service实现类，不用整个项目全改<ol>
<li>程序管理所有实现类对象</li>
<li>程序决定所有对象间关系</li>
</ol>
</li>
<li>灵活重用、扩展。</li>
<li>实现不可见<ol>
<li>靠注解&#x2F;配置文件实现方法调用、对象创建？</li>
<li>只管调用接口方法，程序自己会调用相关实现</li>
</ol>
</li>
</ol>
<p>过程：</p>
<ol>
<li><p>定义Bean</p>
<p> 使用XML或注解(@Component等)方式定义Bean,指定Bean的类名及属性。</p>
</li>
<li><p>配置Spring IOC容器</p>
<p> 通常在XML中配置,指定Bean定义的位置,加载到IOC容器。</p>
</li>
<li><p>初始化IOC容器</p>
<p> 通过ClassPathXmlApplicationContext或AnnotationConfigApplicationContext等初始化IOC容器,触发容器初始化并载入Bean定义。</p>
</li>
<li><p>从IOC容器获取Bean</p>
<p> 根据Bean名称或类型从IOC容器中获取Bean,注入到其他Bean或直接使用。</p>
</li>
</ol>
<h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230729204357252.png" alt="image-20230729204357252"></p>
<h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><h5 id="OC-→-Inverse-of-Control-控制反转"><a href="#OC-→-Inverse-of-Control-控制反转" class="headerlink" title="OC → Inverse of Control 控制反转"></a>OC → Inverse of Control 控制反转</h5><p>控制：实例的生成 （应用程序）</p>
<p>反转：不靠应用程序来生成，靠Spring来生成</p>
<p><span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'><strong>容器</strong></span>：放实例的地方</p>
<p><span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'><strong>组件</strong></span>：放入容器中的实例</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20220705144717205.png" alt="image-20220705144717205"></p>
<h5 id="DI-→-Dependency-Injection依赖注入"><a href="#DI-→-Dependency-Injection依赖注入" class="headerlink" title="DI → Dependency Injection依赖注入"></a>DI → Dependency Injection依赖注入</h5><p>是控制反转的概念的延续</p>
<p>DI做的事情是将容器管理的实例给取出来</p>
<hr>
<p>应用程序、Spring容器，经过控制反转之后，应用和Spring容器谁穷谁富？</p>
<p>依赖：谁依赖谁？为什么？</p>
<p>注入：谁注入谁？注入了什么？</p>
<hr>
<p>注意：<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'><strong>控制反转就是放进去，依赖注入就是取出来</strong></span></p>
<p>优势：</p>
<ul>
<li>减少维护成本</li>
<li>降低服务器的消耗</li>
<li>降低开发成本，不需要额外维护实例之间的关系，在容器中已经维护好了</li>
</ul>
<h4 id="创建Bean组件"><a href="#创建Bean组件" class="headerlink" title="创建Bean组件"></a>创建Bean组件</h4><blockquote>
<p>主要用构造函数形式，无参构造</p>
<p>FactoryBean主要用于整合其他框架</p>
</blockquote>
<ol>
<li><p>构造函数</p>
<p> 在Spring配置文件中定义bean,并指定class和constructor-arg来选择构造函数创建bean。</p>
<p> 👇整个是Bean的注册过程，其中<code>&lt;constructor-arg&gt;</code>ref &#x3D; 是调用了其无参构造函数</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.UserService&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>⭐<strong>FactoryBean</strong></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801231601301.png" alt="image-20230801231601301"></p>
<blockquote>
<p>FactoryBean和BeanFactory的区别，看最后一个单词：</p>
<ol>
<li>Bean在后表示是组件，可推断为工厂类，用于造组建的可能是</li>
<li>Factory在后是说这个是IOC容器规范</li>
</ol>
</blockquote>
<p> 实现FactoryBean接口,在getObjet方法中创建实例。</p>
<p> Spring容器在注册组件过程中，会判断当前对象是否实现了FactoryBean接口，如果实现了会自动调用其中getObject()方法创建实例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;user&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.zyx.bean.FactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p> 👆注册过程，注意类型是User，不是FactoryBean，其中调用了getObject方法</p>
</li>
</ol>
<h4 id="Bean组件注册方式"><a href="#Bean组件注册方式" class="headerlink" title="Bean组件注册方式"></a>Bean组件注册方式</h4><ol>
<li><p>xml</p>
<ol>
<li><p>直接使用&lt;bean&gt;标签,默认是无参构造，如果没有：整一列&lt;constructor-arg name&#x2F;type&#x2F;index &#x3D; “”, value &#x3D; “”&#x2F;&gt;来构造，其中是参数的name或者类型或者下标位置(0~n个下标)</p>
</li>
<li><p>此处涉及组件取出方式</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;app.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">us</span> <span class="operator">=</span> (UserService)ApplicationContext.getBean(<span class="string">&quot;userServiceImpl&quot;</span>);</span><br><span class="line">    userServiceImpl.这里是接口类方法();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>⭐配置类+@Bean注解</p>
<blockquote>
<p>配置框架代码的时候一般是用这一套，SpringBoot推荐</p>
</blockquote>
<ol>
<li><p>步骤：</p>
<ol>
<li>维护对象之间的依赖关系</li>
<li>设置别名</li>
<li>关联特定对象</li>
</ol>
<blockquote>
<p>每个@Bean下跟的都是组件注册方法：</p>
<p>返回值 &#x3D; 注册组件的类型或具体类，建议写接口。</p>
<p>注册的组件名 &#x3D; </p>
<ol>
<li>@Bean（value &#x3D; “自定义”）</li>
<li>默认：方法名</li>
</ol>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Public UserDao <span class="title function_">userDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">us</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">us</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="keyword">return</span> us;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJavaConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">userService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">userDao</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<ol>
<li><hr>
</li>
<li><p>第一种注解获取</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Spring配置类——加注解的那个.class);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">userService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>注意：</p>
<ol>
<li><p>对象间关系没维护好</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731101446552.png" alt="image-20230731101446552"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>⭐配置类+@Component注解</p>
<blockquote>
<p>自己写项目用的是这一套</p>
</blockquote>
<ol>
<li>@ComponentScan：加在@Configuration类头 +（“包目录”）设置扫描包目录</li>
</ol>
<p>   ​    </p>
<ol start="2">
<li>@Component：标记被扫描组件Bean（要被放入容器），可以是xml、可以是类</li>
</ol>
<p>   ​</p>
</li>
</ol>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731102615426.png" alt="image-20230731102615426"></p>
<h3 id="容器中取出组件——注入"><a href="#容器中取出组件——注入" class="headerlink" title="容器中取出组件——注入"></a>容器中取出组件——注入</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230729204440016.png" alt="image-20230729204440016"></p>
<ol>
<li><strong>App…Contenxt。getBean方法</strong></li>
</ol>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731102806840.png" alt="image-20230731102806840"></p>
<p>该方法来自于BeanFactory，又进一步扩展了</p>
<p>也就是说Factory&#x3D;ApplicationContext&#x3D;容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJavaConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">userService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">userDao</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>👆：麻烦</p>
<ol start="2">
<li><p><strong>@Autowired</strong>：封装了getBean，自动获取：</p>
<ol>
<li><p>自动获取实现类</p>
</li>
<li><p>注意自动获取后会有一接口多个实现类的情况，需要@Qualify指定，否则会报错</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731103851482.png" alt="image-20230731103851482"></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731102642180.png" alt="image-20230731102642180"></p>
</li>
</ol>
</li>
</ol>
<p>👆来自于Spring：👇这个是JDK注解：</p>
<ol start="3">
<li><strong>@Resource</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserserviceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao2&quot;)</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource(name = &quot;userDao&quot;)</span></span><br><span class="line">    UserDao userDao2;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>







<img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731103506322.png" alt="image-20230731103506322" style="zoom: 67%;" />







<p>re版本：</p>
<img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731103629377.png" alt="image-20230731103629377" style="zoom:67%;" />



<h3 id="Spring整合单元测试"><a href="#Spring整合单元测试" class="headerlink" title="Spring整合单元测试"></a>Spring整合单元测试</h3><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731110902566.png" alt="image-20230731110902566" style="zoom:67%;" />



<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731110919478.png" alt="image-20230731110919478"></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230729204459647.png" alt="image-20230729204459647"></p>
<h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><ol>
<li>起点</li>
</ol>
<p>  ​    </p>
<pre><code>![image-20230731110909016](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731110909016.png)
</code></pre>
<ol start="2">
<li>调用流程</li>
</ol>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731111538038.png" alt="image-20230731111538038"></p>
<ol>
<li><p>⭐⭐Proceser</p>
<blockquote>
<p>在Spring中,Processor是一个顶级的接口,它允许我们插手Spring容器的生命周期事件。</p>
<p>主要有以下几类Processor:</p>
<ol>
<li><p>BeanFactoryPostProcessor</p>
<p> 允许在容器实例化任何bean之前修改BeanFactory的定义,例如可以用它来注册更多bean。</p>
</li>
<li><p>BeanPostProcessor</p>
<p> 允许我们在初始化方法被调用之前后对bean进行额外处理,经常用来包装bean。</p>
</li>
<li><p>ApplicationContextAwareProcessor</p>
<p> 用于处理实现ApplicationContextAware接口的bean,注入ApplicationContext对象。</p>
</li>
<li><p>ApplicationListenerProcessor</p>
<p> 用于处理实现ApplicationListener接口的bean,将其添加到容器的事件多播器中。</p>
</li>
</ol>
<p>利用这些Processor,我们可以:</p>
<ul>
<li>在容器加载任何bean之前读取配置元数据并做处理;</li>
<li>在bean初始化前后做一些AOP增强处理;</li>
<li>对事件进行监听并做出反应。</li>
</ul>
<p>所以Processor扩展点可以让我们深入到Spring容器的生命周期过程中,进行更多控制或处理。</p>
</blockquote>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731120327762.png" alt="image-20230731120327762"></p>
</li>
<li><p>👆BeanPostProcesser</p>
<blockquote>
<p>在Spring IOC容器中,Processor和BeanPostProcessor都属于扩展点,用于在bean初始化前后做定制化处理。两者关系如下:</p>
<ol>
<li>Processor是顶层接口,规定了容器初始化时的回调方法,可以监听容器事件。</li>
<li>BeanPostProcessor则直接作用于bean级别,用于在bean初始化前后进行回调处理。它是Processor接口的子接口。</li>
<li>BeanPostProcessor通常用于对指定bean做代理增强等处理,而Processor的作用更广,可以实现如事件监听、自定义特殊bean定义等功能。</li>
<li>多个Processor可以定义不同顺序号进行统一回调,而BeanPostProcessor直接按定义顺序依次回调。</li>
<li>BeanFactoryPostProcessor也实现了BeanPostProcessor,所以同时拥有两者功能。</li>
</ol>
<p>总结一下:</p>
<ul>
<li>Processor作用于容器级别,初始化阶段调用;</li>
<li>BeanPostProcessor作用于bean级别,对象实例化阶段调用;</li>
<li>BeanPostProcessor是Processor的子接口,功能更具体。</li>
</ul>
<p>它们都可以扩展Spring容器,实现自定义逻辑,但作用范围和调用时机不同。</p>
</blockquote>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731112029138.png" alt="image-20230731112029138"></p>
<ol>
<li>每注册一个组件都会经过其前后处理</li>
<li><strong>像代理，涉及代理（帮代理制造机会），但不是代理</strong></li>
<li><strong>可以把传入的主实现类换成代理类</strong>：因为</li>
<li>也就是说创造了切口<strong>切的时机</strong></li>
</ol>
</li>
</ol>
<blockquote>
<p>实例：</p>
<ol>
<li>sevlet中没法用Spring组件，@autowaired，没交给spring处理</li>
<li>domain中对象不用放spring，多例。spring中都是单例，一般放mapper、serviceImpl</li>
<li>utils也不用放，都是静态方法</li>
</ol>
<hr>
<ol>
<li><p>在service层中测试：</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731120557834.png" alt="image-20230731120557834"></p>
</li>
<li><p>Proxyutil用jdk代理invoke取到Service对应实现类中用到的<strong>mapper实例</strong></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731125214839.png" alt="image-20230731125214839"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731125200017.png" alt="image-20230731125200017"></p>
</li>
<li><p>配置一下Spring：</p>
<ol>
<li><p>向spring容器中注册service组件，此时还没实例化Impl，也就就没有代理运作</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731115620583.png" alt="image-20230731115620583"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731123120838.png" alt="image-20230731123120838"></p>
</li>
<li><p>processor增强service：加入代理，不直接走service了，在spring中注册代理实现（增强实现）</p>
<ol>
<li><p>无spring最终实现代理：JDK版本</p>
 <img src="../../../../MyNote/MyNote/![](https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/image-20230731132330016.png" alt="image-20230731132330016" style="zoom:200%;" />
</li>
<li><p>⭐有Spring版本：<strong>需要Bean Processor</strong></p>
<ol>
<li>有这个实现就会在Bean注册的时候来这一步。谁监听？</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731132645195.png" alt="image-20230731132645195"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>最后在controller中调用增强的service实现，也就是调用的代理实现，代理起作用了</p>
 <img src="../../../../MyNote/MyNote/![](https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/image-20230731130512423.png" alt="image-20230731130512423" style="zoom:80%;" />

<ol>
<li><p>最关键的一步没画上，学的太傻逼了：@Autowired。依赖注入，实例化组件表面是Service，其实是Component</p>
<blockquote>
<p>Spring 中 Bean 的实例化主要在以下场景中使用:</p>
<ol>
<li><p>依赖注入</p>
<p> Spring 通过依赖注入(DI)的方式,将配置好的Bean实例注入到需要它的类中。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过ApplicationContext获取</p>
<p> 从Spring容器中获取Bean实例进行使用。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Bean工厂方法</p>
<p> Spring管理的Bean也可以直接通过new创建实例。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Bean后处理</p>
<p> 通过BeanPostProcessor可以自定义修改Bean实例。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBeanProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">    <span class="comment">// 在初始化前处理</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="容器初始化"><a href="#容器初始化" class="headerlink" title="容器初始化"></a>容器初始化</h4><h4 id="容器关闭"><a href="#容器关闭" class="headerlink" title="容器关闭"></a>容器关闭</h4><p>整个Processor类似于Filter，这俩就是俩方法，要干什么写进去就行，对每个创建的Bean都会执行</p>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230729204528215.png" alt="image-20230729204528215"></p>
<h2 id="🥬AOP"><a href="#🥬AOP" class="headerlink" title="🥬AOP"></a>🥬AOP</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230729204757781.png" alt="image-20230729204757781"></p>
<p>1. </p>
<hr>
<p>替代了代理。</p>
<ol>
<li><p>实现：在方法前后添加功能或操作。</p>
</li>
<li><p>前任缺点：要把代理操作实现在ProxyUtil中，要改的话很不方便。也就是增强代码和主实现类完全不在一块内容中</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731145619040.png" alt="image-20230731145619040"></p>
<p> 红色(主实现类)和绿色(增强代码：前后)可以动态结合，不需要了或者想换一个直接解除关联就行</p>
</li>
<li><p>解决：第三方功能模块对<strong>增强代码</strong>和<strong>业务代码</strong>进行<strong>管理</strong>和<strong>组合</strong></p>
</li>
</ol>
<hr>
<p>面向切面编程：</p>
<p><strong>切面Aspect</strong>：切入点+通知</p>
<ol>
<li><p><strong>通知Advice</strong>：就是<font color='red'>增强代码&lt;(绿)</p>
<ol>
<li>前置</li>
<li>后置</li>
<li>环绕：前后分别</li>
<li>👆根据加在业务代码的位置分</li>
<li>返回结果：接收连接点返回值</li>
<li>异常：捕获过程</li>
</ol>
</li>
<li><p><strong>切入点PointCut</strong>：表达式：增强代码和业务<strong>相关联</strong>的<strong>匹配规则</strong></p>
</li>
<li><p><strong>连接点JoinPoint</strong>：<strong>运行中</strong>的<font color='red'>业务方法</font>(动态红)</p>
</li>
<li><p>委托类：委托类对象</p>
</li>
<li><p>代理类：代理类对象：看有接口没：JDK&#x2F;Cglib</p>
</li>
<li><p>织入：将通知应用到目标对象，进而生成代理对象的过程动作（通知+连接点）</p>
</li>
</ol>
<p>  ​    </p>
<h3 id="👆SpringAOP"><a href="#👆SpringAOP" class="headerlink" title="👆SpringAOP"></a>👆SpringAOP</h3><p>实例：半自动方式：通知、委托的类级别关联（<strong>不如方法级别关联灵活，但是单独靠Spring没法再进一步了</strong>）</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731154756596.png" alt="image-20230731154756596"></p>
<ol>
<li><p>创建advice，在其中写增强</p>
</li>
<li><p>在Spring设置中：@Bean创建关联ProxyFactoryBean，实现业务代码和增强代码的关联，也就是代理类和Impl的联系，创建了一个代理类</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731152950992.png" alt="image-20230731152950992"></p>
<ol>
<li><p>为什么1处可以用名称获得？BeanFactory——nameAward</p>
</li>
<li><p>注册的是BeanFactory，其实是UserService类型，如果不在用的时候@Qualify会报错</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731155206078.png" alt="image-20230731155206078"></p>
</li>
</ol>
</li>
</ol>
<h3 id="👆AspectJ"><a href="#👆AspectJ" class="headerlink" title="👆AspectJ"></a>👆AspectJ</h3><p>为了全自动AOP：方法级别关联</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230729204657713.png" alt="image-20230729204657713"></p>
<hr>
<p>引入：切入点表达式：关联对应的增强代码和业务方法</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731162034281.png" alt="image-20230731162034281"></p>
<h4 id="⭐切入点表达式"><a href="#⭐切入点表达式" class="headerlink" title="⭐切入点表达式"></a>⭐切入点表达式</h4><ol>
<li><p><strong>Excution</strong></p>
<blockquote>
<p>类似正则表达式的匹配规则：</p>
<p>用在大范围匹配中</p>
<p>语法：</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731160644011.png" alt="image-20230731160644011"></p>
<ul>
<li><p>如果要匹配com.zyx.service.impl.AdminServiceImpl中所有方法,可以使用如下execution表达式:</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.zyx.service.impl.AdminServiceImpl.*(..))</span><br></pre></td></tr></table></figure>
</li>
<li><p>execution表达式的语法规则为:</p>
<ul>
<li><p>execution() 是表达式的根,是必须的。</p>
</li>
<li><p>第一个<code>*</code>代表任意返回值类型。</p>
</li>
<li><p>com.zyx.service.impl.AdminServiceImpl 是类全限定名。</p>
</li>
<li><p>第二个<code>*</code>代表类中的任意方法。</p>
</li>
<li><p>(..) 表示任意参数类型。</p>
</li>
</ul>
</li>
<li><p>execution表达式的基本语法是:</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(返回值类型 包名.类名.方法名(参数列表))</span><br></pre></td></tr></table></figure>

<p>  各个部分可以精确匹配,也可以使用<code>*</code>通配符进行通配。</p>
<p>  除了<code>execution()</code>,AspectJ还支持<code>within()</code>、<code>this()</code>、<code>target()</code>等切点表达式,提供了很强大的切点描述能力。</p>
</li>
</ul>
<p>很难做到精准匹配，需要用下面的Annotation</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.xyz.service.*.save(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateSave</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//调用save方法前执行验证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> execution表达式提供了丰富的语法来定义切点。</p>
</li>
<li><p><strong>Annotation</strong></p>
<blockquote>
<p>自定义注解的方式实现</p>
<p>用在精准配中</p>
</blockquote>
<ol>
<li><p>定义一个注解,比如@Log:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在需要的方法上使用该注解:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Aspect类中使用@annotation方式指定切点:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;@annotation(Log)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="❌advicor"><a href="#❌advicor" class="headerlink" title="❌advicor"></a>❌advicor</h4><p>早，依靠xml，没注解，和Spingboot不兼容</p>
<h4 id="✅aspect"><a href="#✅aspect" class="headerlink" title="✅aspect"></a>✅aspect</h4><p>实现方式：</p>
<ol>
<li><p>❌XML方式：</p>
<blockquote>
<ol>
<li><p>实现Impl</p>
<p> 类似于此</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731164222717.png" alt="image-20230731164222717"></p>
</li>
<li><p>实现aspect</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731163543447.png" alt="image-20230731163543447"></p>
</li>
<li><p>设置表达式，在app.xml中，关联上面两个</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731163335660.png" alt="image-20230731163335660"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731164631745.png" alt="image-20230731164631745"></p>
</li>
<li><p>实例化容器+组件</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731163649174.png" alt="image-20230731163649174"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/image-20230731164345245.png" alt="image-20230731164345245"></p>
</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li><p>如果不想要什么方法的加强了，只需要在xml文件中把相关联的那句话删掉就行</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731164716459.png" alt="image-20230731164716459"></p>
</li>
<li></li>
</ol>
</blockquote>
</li>
<li><p>✅注解方式：</p>
<blockquote>
<p>需要用到注解的地方：替换xml而已</p>
<ol>
<li><p>声明一个切面@Aspect</p>
<ol>
<li>其中@Pointcut设置一个方法名称为切入点编号</li>
<li>@设置各个</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731171630092.png" alt="image-20230731171630092"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731171619280.png" alt="image-20230731171619280"></p>
</li>
<li><p>实例化中</p>
<ol>
<li>读取配置</li>
<li>123</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731171756200.png" alt="image-20230731171756200"></p>
</li>
</ol>
</blockquote>
<hr>
<blockquote>
<ol>
<li>logAspect<ol>
<li>pt1</li>
</ol>
</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<p>以上两种共同的执行顺序：</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731170431575.png" alt="image-20230731170431575"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230731170627290.png" alt="image-20230731170627290"></p>
</blockquote>
</li>
</ol>
<h3 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h3><ol>
<li><p>静态代理，double Impl，用的时候用代理版本的Impl，很不方便，所有的实现都要写两份</p>
</li>
<li><p>有ProxyUtil，其中对Impl进行JDK&#x2F;Cglib实现<strong>动态</strong>代理，有无接口用继承。最后直接通过实例化ProxyUtil使用代理</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801094811079.png" alt="image-20230801094811079"></p>
</li>
<li><p>将Impl放入Spring（@Service）</p>
<ol>
<li><p>组件Service被BeanPostProcessor处理后才放入容器Context中</p>
</li>
<li><p>在Processor中狸猫换太子，进行代理添加</p>
</li>
<li><p>自己实现一个DynamicProxyProcessor，其中实现ProxyUtil的实例化，将原先的组件Service用代理Component替代</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801095407505.png" alt="image-20230801095407505"></p>
</li>
</ol>
</li>
<li><p>将ProxyUtil中的代码解耦，半自动：虽然独立出来代理类但是和委托类还是强关联</p>
<ol>
<li><p>单独将代理提取成一个类</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/image-20230801100313033.png" alt="image-20230801100313033"></p>
</li>
<li><p>最终注册组件还是注册Proxy，其中将代理类和实现类进行了关联</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801100525178.png" alt="image-20230801100525178"></p>
</li>
</ol>
</li>
<li><p>将半自动升级为全自动：AspectJ将代理实现类和委托类关联，可以单独按照顺序编写增强代码，实现解耦。</p>
<blockquote>
<p>表达式范围广，注解</p>
</blockquote>
<ol>
<li><p>造一个切面，传进去的切点JoinPoint，切面中的增强方法可通过其获得连接点信息（也就是被切的方法）包含委托类、其方法成员</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801101633475.png" alt="image-20230801101633475"></p>
</li>
<li><p>其中</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801103404732.png" alt="image-20230801103404732"></p>
</li>
<li><p>类似于</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801103715687.png" alt="image-20230801103715687"></p>
</li>
</ol>
<blockquote>
<p>注解版本：</p>
<ol>
<li><p>编写自定义注解</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801112010129.png" alt="image-20230801112010129"></p>
</li>
<li><p>造切面：</p>
<ol>
<li>在原来表达式的地方写@Annotation</li>
<li>关联注解（写谁方法头上谁受代理）和通知增强</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801111410231.png" alt="image-20230801111410231"></p>
</li>
</ol>
</blockquote>
</li>
</ol>
<p>为什么能直接通过名字获取的问题！！！</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801114836598.png"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801114836598.png" alt="image-20230801114836598"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801150950547.png" alt="image-20230801150950547"></p>
<h2 id="🥬事务TX"><a href="#🥬事务TX" class="headerlink" title="🥬事务TX"></a>🥬事务TX</h2><blockquote>
<p>Spring整合Mybatis</p>
<hr>
<p>SqlSessionFactory——单例，可放——接口，没法放——需要mybatis对Spring提供支持</p>
<hr>
<p>在Spring设置中：</p>
<ol>
<li><p>导包（前置）</p>
</li>
<li><p>处理SqlSession</p>
<ol>
<li><p>注册SqlSessionFactoryBean——用@Bean方式</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801114948267.png" alt="image-20230801114948267"></p>
</li>
<li><p>连接池，也是@Bean</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801114953442.png" alt="image-20230801114953442"></p>
</li>
</ol>
</li>
<li><p>⭐处理Mapper直接注册——到时候@autowired获取</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801115003068.png" alt="image-20230801115003068"></p>
</li>
</ol>
<hr>
<p>使用：</p>
<ol>
<li>Service</li>
<li>domain</li>
<li>mapper</li>
</ol>
</blockquote>
<h3 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么"></a>事务是什么</h3><p><a href="">MySQl事务</a>：</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801150146256.png" alt="image-20230801150146256"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801144539847.png" alt="image-20230801144539847"></p>
<h3 id="Spring管理事务"><a href="#Spring管理事务" class="headerlink" title="Spring管理事务"></a>Spring管理事务</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230729204858468.png" alt="image-20230729204858468"></p>
<p>进化史：</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801153122070.png" alt="image-20230801153122070"></p>
<h4 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h4><blockquote>
<p>DataSourceTransactionManager是一个平台事务管理器的实现类。</p>
<p>TransactionTemplate便是一个事务定义的实现类。</p>
</blockquote>
<ol>
<li><p>在SpringConfig中</p>
<ol>
<li><p>设置123Bean</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801151633827.png" alt="image-20230801151633827"></p>
</li>
<li><p>设置123Bean</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801151636409.png" alt="image-20230801151636409"></p>
</li>
</ol>
</li>
<li><p>在Impl中</p>
<ol>
<li><p>生成上面那俩的实现类</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801151855412.png" alt="image-20230801151855412"></p>
</li>
<li><p>最终的代码写在内部类（功能接口）中：其中transactionTemplate式上面的</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230801151443485.png" alt="image-20230801151443485"></p>
</li>
</ol>
</li>
</ol>
<p>👆源码分析：</p>
<p>有点像Proxy的InnotationHandler</p>
<p>又有点像环绕通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.excute(<span class="keyword">new</span> <span class="title class_">TransactionCallBack</span>&lt;Object&gt;&#123;</span><br><span class="line">	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>











<h3 id="⭐声明式事务"><a href="#⭐声明式事务" class="headerlink" title="⭐声明式事务"></a>⭐声明式事务</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230729204922005.png" alt="image-20230729204922005"></p>
<ol>
<li><p>SpringConfig：组件管理</p>
<ol>
<li>@EnableTransactionManagement</li>
<li>注册DataSource</li>
<li>注册SqlSessionFactory，关联DataSource</li>
<li>注册MapperScannerConfigurer关联mapper包和SqlSession</li>
<li>注册PlatformTransactionManager关联DataSource（不用事务——注册事务定义）</li>
</ol>
</li>
<li><p>ServiceImpl</p>
<blockquote>
<p>与上面不一样的是</p>
</blockquote>
<p> ⭐在需要保障事务的代码上：**@Transactional**（AOP Aspect——自定义注解：用编程式实现声明式）</p>
<blockquote>
<p>@Transactional详解：</p>
<ol>
<li>可以直接加在类上，其中方法都会加紧事务管理中</li>
<li>阿斯顿</li>
</ol>
</blockquote>
</li>
<li><p>使用：</p>
<ol>
<li>service接口注入</li>
<li>测试类中<ol>
<li>接口直接Service方法调用</li>
</ol>
</li>
</ol>
</li>
<li><p>阿斯顿</p>
</li>
</ol>
<h1 id="⚙️SpringMVC"><a href="#⚙️SpringMVC" class="headerlink" title="⚙️SpringMVC"></a>⚙️SpringMVC</h1><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230802112814803.png" alt="image-20230802112814803"></p>
<blockquote>
<p>整合了sevlet，其中根据请求分发方法被整合，，可直接按照注解方式取得&#x2F;xxx对应的xxx方法</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230802113920654.png" alt="image-20230802113920654"></p>
</blockquote>
<h2 id="⚙️底层流程"><a href="#⚙️底层流程" class="headerlink" title="⚙️底层流程"></a>⚙️底层流程</h2><p>其实是一个缺省servlet（”&#x2F;“）</p>
<p>所以其所有实现还是交给tomcat服务器处理。而且mvc的applicationInitializer就是跟tomcat去注册这个“缺省servlet”</p>
<blockquote>
<p>servlet捕获请求，</p>
<p>缺省servlet：没有接收的servlet就交给它</p>
<p>如tomcat有专门处理jsp的servlet（“*.jsp”）优先级&lt;(“&#x2F;*“)</p>
</blockquote>
<ol>
<li>问题：缺省servlet重写后，没法响应resource文件</li>
<li>问题：&#x2F; 和&#x2F;* 的区别</li>
</ol>
<p>底层流程的核心入口：doDisparcher还是什么</p>
<ol>
<li>重写了一些servlet的方法</li>
</ol>
<h2 id="⚙️两种引入，配置类"><a href="#⚙️两种引入，配置类" class="headerlink" title="⚙️两种引入，配置类"></a>⚙️两种引入，配置类</h2><blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>编写启动类</li>
<li>重写其中方法，spring配置web配置dispatcher</li>
<li>编写Spring配置类、web配置类、dispatcher servlet的urlpattern</li>
</ol>
<p>的原理：</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230803094132258.png" alt="image-20230803094132258"></p>
<p>tomcat调用该实现类，进一步去读取了启动类，启动类中有三种配置</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>@Enable。。。：</p>
<p>包含了@Configuration，</p>
</blockquote>
<ol>
<li><p>xml版本：</p>
<ol>
<li>web.xml tomcat——》产生dispatcher servlet ——》application.xml</li>
<li></li>
</ol>
<p> <strong>XML配置</strong></p>
<ol>
<li><p>在web.xml中配置DispatcherServlet</p>
<p> 指定servlet名称、类、load-on-startup等</p>
</li>
<li><p>配置url映射</p>
<p> 设置servlet的url映射模式</p>
</li>
<li><p>设置初始化参数</p>
<p> 指定Spring配置文件位置</p>
</li>
</ol>
<p> <strong>初始化类配置</strong></p>
<ol>
<li><p>实现WebApplicationInitializer</p>
<p> 实现onStartup方法</p>
</li>
<li><p>创建DispatcherServlet实例</p>
<p> 通过代码new一个DispatcherServlet</p>
</li>
<li><p>注册DispatcherServlet</p>
<p> 调用ServletContext的addServlet方法注册</p>
</li>
<li><p>配置映射路径</p>
<p> 调用registration的addMapping指定路径映射</p>
</li>
</ol>
<p> 两者对比:</p>
<ul>
<li>XML方式更简单直观,初始化类方式灵活程度更高</li>
<li>初始化类方式可以完全避免XML配置</li>
<li>初始化类方式可以在代码中注入bean等,功能更强大</li>
</ul>
</li>
<li><p>config配置类</p>
<blockquote>
<p>整合mybatis一个配置类，整合servlet一个配置类，普通自己注册Bean一个配置类。</p>
<p>为了解耦</p>
<p>也可看出配置类就是IOC把需要的组件加进来，Spring要想整理这些框架</p>
</blockquote>
<ol>
<li><p>web.xml中</p>
<ol>
<li><strong>不用这玩意了，无xml化</strong></li>
</ol>
</li>
<li><p>config包中：</p>
<ol>
<li><p>建立一个app初始化类注册DispatcherServlet:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext container)</span> &#123;</span><br><span class="line">    <span class="type">DispatcherServlet</span> <span class="variable">dispatcherServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> container.addServlet(<span class="string">&quot;appDispatcher&quot;</span>, dispatcherServlet);</span><br><span class="line">    registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registration.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>建立一个MVCConfig独立于SpringConfig</p>
<ol>
<li>@EnableWebMVC</li>
<li>@ComponentScan(“com.xxx.controller”)</li>
</ol>
</li>
<li><p>其他的COnfig配置文件中的@Component排除</p>
<blockquote>
<p>需要注意：</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230802171342166.png" alt="image-20230802171342166"></p>
</blockquote>
<ol>
<li><p>方式1</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230802115026768.png" alt="image-20230802115026768"></p>
</li>
<li><p>方式2：简化写法</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230802115335989.png" alt="image-20230802115335989"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>controller中的写法</p>
 <img src="../../../../MyNote/MyNote/![](https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/image-20230802115703995.png" alt="image-20230802115703995" style="zoom:67%;" /></li>
</ol>
</li>
</ol>
<h2 id="👇以下都是加在”Handler“方法上的"><a href="#👇以下都是加在”Handler“方法上的" class="headerlink" title="👇以下都是加在”Handler“方法上的"></a>👇以下都是加在”Handler“方法上的</h2><h2 id="⚙️-RequestMapping（）"><a href="#⚙️-RequestMapping（）" class="headerlink" title="⚙️@RequestMapping（）"></a>⚙️@RequestMapping（）</h2><ol>
<li>加强版@WebServlet(“&#x2F;…”)<ol>
<li>如何复刻servlet？可加在Controller头上，也可加在其中方法头上，自动拼接urlpattern和“&#x2F;”</li>
<li></li>
</ol>
</li>
<li>6个参数：不写默认全收<ol>
<li>value：urlpattern规定，每个独立@中可自动拼&#x2F;</li>
<li>method：</li>
<li>param：参数限定</li>
<li>headers：加token请求头，限定访问，请求要加token才能正常访问</li>
<li>consumes：请求类型限定，规定请求content-type，文件类型</li>
<li>produces响应类型限定</li>
</ol>
</li>
</ol>
<h2 id="⚙️返回值-格式"><a href="#⚙️返回值-格式" class="headerlink" title="⚙️返回值+格式"></a>⚙️返回值+格式</h2><ol>
<li><p>JSON返回值</p>
<ol>
<li><p>导包</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230803113103976.png" alt="image-20230803113103976"></p>
</li>
<li><p>@ResponseBody</p>
<ol>
<li><p>可加方法，可加类（其中所有方法都是返回JSON字符串）</p>
</li>
<li><p>写法：</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230803113526753.png" alt="image-20230803113526753"></p>
<p> 加注解的方法返回值会被转化为JSON格式输出</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>视图返回值格式</p>
<ol>
<li>阿斯顿</li>
</ol>
</li>
</ol>
<h2 id="⚙️方法参数"><a href="#⚙️方法参数" class="headerlink" title="⚙️方法参数"></a>⚙️方法参数</h2><h3 id="GET-key-value形式-接收"><a href="#GET-key-value形式-接收" class="headerlink" title="GET+key-value形式 接收"></a>GET+key-value形式 接收</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230803115251147.png" alt="image-20230803115251147"></p>
<ol>
<li>按同名接收<ol>
<li>自己直接设置接收类型</li>
<li>多个，设置数组，按名字转</li>
</ol>
</li>
</ol>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote>
<p>原方式：@multiPartUpload+Part</p>
</blockquote>
<p>1.导包，导入commons-fileupload jar包</p>
<p><strong>2.向容器中注册MultipartResolver组件,注意，组件的编号必须是multipartResolver，否则无法解析。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CommonsMultipartResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3.在处理文件上传时，只需要在handle方法中有MultipartFile来接收即可，变量的名称要求和上传文件的name属性相同即可。</p>
<p>​	handle方法中有MultipartFile来接，变量名称要和上传文件的的name属性相同！</p>
<p>​	图片存储：到硬盘因Jar非war</p>
<ol>
<li>设置盘符路径</li>
<li>文件名改uuid+保留后缀名</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//变量的名称要求和上传文件的name属性名称保持一致</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;upload1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">upload</span><span class="params">(MultipartFile image)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要将文件写入到硬盘上某处，那么需要设定一个硬盘路径</span></span><br><span class="line">        <span class="comment">//实际上，在使用SpringMVC或者后面的SpringBoot来进行项目开发时，我们反而不建议大家设定应用根目录为存储的路径了，为什么呢？因为后续使用SpringBoot时，主要是打jar包运行，如果设定存储的路径为应用根目录，则无法访问到</span></span><br><span class="line">        <span class="comment">//所以后面的建议是设定某个盘符目录保存，去设定一个映射即可</span></span><br><span class="line">        <span class="comment">//先将图片进行存储，存储到D:/upload目录中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">        <span class="comment">//将文件的名称改为uuid生成的字符的名称，但是需要保留文件的后缀名</span></span><br><span class="line">        filename = UUID.randomUUID() + filename.substring(filename.indexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/upload/&quot;</span> + filename;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(path));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后，接收key&#x3D;value类型的参数，还可以使用一个引用类型的对象来接收，只需要保障对象的成员变量的名称和请求参数的名称一致，并且提供set方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// /param1?course=python&amp;course=java&amp;course=c&amp;username=zhangsan&amp;password=admin123&amp;gender=male&amp;birthday=1999-10-01</span></span><br><span class="line">    <span class="comment">//直接在方法的形参中用同名的变量来接收即可</span></span><br><span class="line">    <span class="comment">//但是还有一种更加简便的方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;param1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">param1</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;param1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;param2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">param2</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;param2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804094335506.png" alt="image-20230804094335506"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804094339646.png" alt="image-20230804094339646"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol>
<li><p>controller</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804102651972.png" alt="image-20230804102651972"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804102658189.png" alt="image-20230804102658189"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804102706590.png" alt="image-20230804102706590"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804102710473.png" alt="image-20230804102710473"></p>
</li>
<li><p>service</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804102751010.png" alt="image-20230804102751010"></p>
</li>
</ol>
<h3 id="POST-JSON接发"><a href="#POST-JSON接发" class="headerlink" title="POST+JSON接发"></a>POST+JSON接发</h3><ol>
<li><p>JSON发送</p>
<ol>
<li><p>格式</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804112352387.png" alt="image-20230804112352387"></p>
</li>
<li><p>原来：</p>
<ol>
<li>Axios组件发送JSON字符串</li>
</ol>
</li>
<li><p>现在：postman</p>
</li>
</ol>
</li>
<li><p>JSON接收</p>
<ol>
<li><p>原来</p>
<ol>
<li>直接JacksonUtil的</li>
<li>JacksonUtil的ObjectMapper</li>
</ol>
</li>
<li><p>@RequestBody+String</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804111355166.png" alt="image-20230804111355166"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804111420428.png" alt="image-20230804111420428"></p>
</li>
<li><p>@RequestBody+Map</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804111552253.png" alt="image-20230804111552253"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804111557178.png" alt="image-20230804111557178"></p>
</li>
<li><p>@RequestBody+引用类型的对象接收</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804111945272.png" alt="image-20230804111945272"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804111950710.png" alt="image-20230804111950710"></p>
<ol>
<li>BO，用来接收：大，字段多，有很多不一样的表，传进来的也是很多表的数据，其中成员一般是多个需求表的引用类</li>
<li>VO，用来表达，将涉及多表数据整合</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="其他类型-JavaEE对象"><a href="#其他类型-JavaEE对象" class="headerlink" title="其他类型-JavaEE对象"></a>其他类型-JavaEE对象</h3><blockquote>
<p>接收EE对象（熟悉）如果希望在handle方法中使用HttpServletRequest、HttpServletResponse、HttpSession等对象，那么也是直接在方法的形参中直接接收即可。对于cookie对象的获取，需要借助于HttpServletRequest</p>
</blockquote>
<h4 id="使用HttpServletRequest、Response："><a href="#使用HttpServletRequest、Response：" class="headerlink" title="使用HttpServletRequest、Response："></a>使用HttpServletRequest、Response：</h4><ol>
<li>req、resp：以下两种都需要先获取这个</li>
</ol>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804113427196.png" alt="image-20230804113427196"></p>
<ol start="2">
<li>cookie</li>
</ol>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804113452853.png" alt="image-20230804113452853"></p>
<ol start="3">
<li><p>session</p>
<ol>
<li><p>session赋值</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804113553339.png" alt="image-20230804113553339"></p>
</li>
<li><p>session取值方式1</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804113610739.png" alt="image-20230804113610739"></p>
</li>
<li><p>session取值方式2</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804113836036.png" alt="image-20230804113836036"></p>
</li>
</ol>
</li>
</ol>
<h2 id="⚙️RESTful接口"><a href="#⚙️RESTful接口" class="headerlink" title="⚙️RESTful接口"></a>⚙️RESTful接口</h2><blockquote>
<p>REST风格的接口。</p>
<p>RESTful是一种软件架构风格,用于对API进行设计和开发。主要有以下几个特点:</p>
<ol>
<li>资源(Resources):RESTful把每一个URI当做一种资源来对待。</li>
<li>表现层(Representation):资源的表现形式可以是JSON、XML、图片等,客户可以指定接收哪种格式。</li>
<li>状态转移(State Transfer):客户端通过HTTP动词改变资源状态。常用的动词有GET、POST、PUT、DELETE。</li>
<li>统一接口(Uniform Interface):每个资源只有一个URI,所有操作在这个地址进行。</li>
</ol>
<p>主要优点有:</p>
<ul>
<li>系统架构清晰,符合互联网软件特点</li>
<li>可根据URL直接访问资源,使用灵活</li>
<li>标准化接口,易于对接</li>
<li>可扩展性强,低耦合</li>
</ul>
<p>RESTful经常用于设计提供数据访问服务的Web API。它简化了接口,易于理解和实现,是目前最流行的一种Web API设计。</p>
</blockquote>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><ol>
<li><p>老版本：同一地址，根据请求方法分</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804114242252.png" alt="image-20230804114242252"></p>
</li>
<li><p>新版本：根据请求资源不同分</p>
<p> <strong>命名规则：名词(资源)+动作</strong></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804114345702.png" alt="image-20230804114345702"></p>
</li>
</ol>
<h3 id="请求URL的一部分"><a href="#请求URL的一部分" class="headerlink" title="请求URL的一部分"></a>请求URL的一部分</h3><ol>
<li>@PathVariable &#x3D; 获取URL的一部分</li>
<li>👆相当于之前的获取URI然后String.replace</li>
</ol>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804120130328.png" alt="image-20230804120130328"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804120134883.png" alt="image-20230804120134883"></p>
<h3 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h3><ol>
<li><p>以前</p>
</li>
<li><p>现在：@RequestParam</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804144549385.png" alt="image-20230804144549385"></p>
</li>
</ol>
<h3 id="获取请求头"><a href="#获取请求头" class="headerlink" title="获取请求头"></a>获取请求头</h3><ol>
<li><p>以前</p>
<ol>
<li>req.getHeader</li>
<li>123</li>
</ol>
</li>
<li><p>现在：@RequestHeader</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804144855467.png" alt="image-20230804144855467"></p>
</li>
</ol>
<h3 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h3><ol>
<li><p>原来：（纯JavaEE servlet）</p>
<ol>
<li><p>获取+赋值</p>
<p> req的形参接收，使用req.getCookies来获取cookie对象，进一步去获取其中对象</p>
<ol>
<li>获取请求的Cookie</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cookies != <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给出响应</p>
<ol start="2">
<li>设置响应的Cookie</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">3600</span>); </span><br><span class="line">cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<p> 这个案例中:</p>
<ul>
<li>从request中获取所有Cookie数组</li>
<li>通过getName()和getValue()获取cookie的键值</li>
<li>创建一个新的Cookie对象,设置maxAge和path</li>
<li>通过response添加这个cookie到响应中</li>
</ul>
<p> servlet接口提供了简单的cookie管理功能,可以方便获取和设置cookie。</p>
</li>
</ol>
</li>
<li><p>现在：@CookieValue</p>
<ol>
<li>赋值，不含@Cookie</li>
</ol>
<p>   ​    </p>
<ol start="2">
<li>取值，含@cookie</li>
</ol>
<p>   ​</p>
</li>
</ol>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ol>
<li><p>以前：（纯JavaEE servlet）</p>
<p> Servlet中处理Session的示例代码如下:</p>
<ol>
<li>获取Session对象</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>存储 Session 属性</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取 Session 属性</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>移除 Session 属性</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.removeAttribute(<span class="string">&quot;key&quot;</span>); </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>销毁Session</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure>

<p> 其中主要是通过HttpServletRequest提供的getSession()方法获取HttpSession对象,然后可以调用setAttribute&#x2F;getAttribute&#x2F;removeAttribute等方法对Session进行操作。</p>
<p> 另外可以通过session.setMaxInactiveInterval()设置Session超时时间。</p>
<p> Servlet中的Session机制为管理用户状态提供了便利,是Web应用的重要部分。</p>
</li>
<li><p>现在</p>
<ol>
<li>赋值</li>
<li>取值</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804145649217.png" alt="image-20230804145649217"></p>
</li>
</ol>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><ol>
<li><p>之前：</p>
<blockquote>
<p>转发包含会经过多次filter</p>
</blockquote>
<p> Servlet Filter用于对Servlet请求进行预处理和后处理,常用的实现步骤:</p>
<ol>
<li>实现Filter接口,实现其doFilter方法</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span>&#123;</span><br><span class="line">    <span class="comment">//前置处理</span></span><br><span class="line">    </span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后置处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在web.xml中配置Filter</li>
</ol>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>MyFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.test.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>MyFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>在doFilter方法中,调用chain.doFilter传入请求响应,以让请求继续流转。</p>
</li>
<li><p>可以在doFilter前后添加预处理和后处理逻辑。</p>
</li>
</ol>
<p> Filter适合处理编码、日志、权限等横切关注点,可以代替拦截器实现类似功能。</p>
</li>
<li><p>现在：</p>
<ol>
<li><p>概念：</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804151402105.png" alt="image-20230804151402105"></p>
<blockquote>
<p>微调：一次请求只会经过一次filter，默认urlpattern范围&#x2F;*，之后会给设置（SpringBoot）</p>
</blockquote>
</li>
<li><p>编写</p>
</li>
<li><p>实现</p>
</li>
</ol>
</li>
</ol>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804151048595.png" alt="image-20230804151048595"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804150853161.png" alt="image-20230804150853161"></p>
<h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><blockquote>
<p>类似于Filtter，可放行拦截，原理不同</p>
<hr>
<p>Interceptor和Filter的执行顺序是:</p>
<p>请求:</p>
<p>Filter -&gt; DispatcherServlet -&gt; Interceptor</p>
<p>响应:</p>
<p>Interceptor -&gt; DispatcherServlet -&gt; Filter</p>
<p>123</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804152950121.png"></p>
</blockquote>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804152950121.png" alt="image-20230804152950121"></p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804152826225.png" alt="image-20230804152826225"></p>
<p>遍历所有的Interceptor，若对了就下一个，不对就返回，执行不到handler</p>
<h2 id="⚙️Converter类型转换器"><a href="#⚙️Converter类型转换器" class="headerlink" title="⚙️Converter类型转换器"></a>⚙️Converter类型转换器</h2><h2 id="⚙️全局异常处理"><a href="#⚙️全局异常处理" class="headerlink" title="⚙️全局异常处理"></a>⚙️全局异常处理</h2><p>任何地方的一场都可以捕获处理</p>
<ol>
<li><p>异常</p>
<p> ​	<img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804155427887.png" alt="image-20230804155427887"></p>
</li>
<li><p>处理</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804155429587.png" alt="image-20230804155429587"></p>
</li>
</ol>
<h2 id="⚙️静态资源处理"><a href="#⚙️静态资源处理" class="headerlink" title="⚙️静态资源处理"></a>⚙️静态资源处理</h2><ol>
<li><p>之前：见项目1文件上传的wx&#x2F;storage&#x2F;fetch</p>
<ol>
<li>使命：找到并把本机图片响应出去</li>
</ol>
</li>
<li><p>现在：注册文件上传(web上传)组件</p>
</li>
</ol>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804160124235.png" alt="image-20230804160124235"></p>
<p>将“**”前的所有去掉，替换为根目录“&#x2F;”</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804160134562.png" alt="image-20230804160134562"></p>
<p>一个规则，三种路径：<strong>找到并把本机图片响应出去</strong>，用IO流</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804160801329.png" alt="image-20230804160801329"></p>
<p>通用写法：</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230804161201950.png" alt="image-20230804161201950"></p>
<blockquote>
<p>在Java IO中,ResourceHandler是一种用于处理和加载各种资源文件的接口。它的主要作用是提供一致的方式来访问不同来源的资源,屏蔽不同的底层访问细节。</p>
<p>ResourceHandler的工作原理主要是:</p>
<ol>
<li>提供统一的资源访问API,例如getResource(),getInputStream()等。这些方法都针对抽象的资源,而不是具体的文件。</li>
<li>内部维护一个或多个ResourceLoader的实例,用来找到并加载不同来源的资源,如文件系统,网络等。</li>
<li>调用ResourceLoader来查找和读取资源,然后再返回一个对应的Resource对象。</li>
<li>应用程序通过ResourceHandler统一的API使用资源,而不用关心具体细节。</li>
<li>可以扩展和自定义新的ResourceLoader来支持更多资源源,对外提供一致接口。</li>
<li>常用实现类有DefaultResourceHandler、FileSystemResourceHandler等。</li>
</ol>
<p>这样ResourceHandler就起到了适配器的作用,对外提供统一接口,内部实现处理各种类型的资源。它提高了资源访问的灵活性和扩展性。</p>
</blockquote>
<h1 id="🚀SpringBoot"><a href="#🚀SpringBoot" class="headerlink" title="🚀SpringBoot"></a>🚀SpringBoot</h1><h2 id="🚀介绍"><a href="#🚀介绍" class="headerlink" title="🚀介绍"></a>🚀介绍</h2><p>简化配置类</p>
<p>约定大于配置：写死了规则，只需遵守约定即可</p>
<p><strong>SpringBoot中,对于那些写在 starter 中的类,我们只需要把这些 starter 的依赖配置在pom文件中, 当SpringBoot启动的时候, 这些类就会自动的被 SpringBoot扫描然后将他们注册为bean 交给SpringBoot去管理</strong></p>
<blockquote>
<p>调用set方法、使用Id。。。需要名字用对了才能正确调用</p>
<p>如果规则不一样，需要调用的时候有合并逻辑</p>
<blockquote>
<ol>
<li>设置接口</li>
<li>在实现类中进行相关的转换</li>
<li>注解中设置接口参数属性</li>
<li></li>
</ol>
</blockquote>
</blockquote>
<p><strong>没配置@Scan，自动扫描的是app类所在的包</strong></p>
<ul>
<li><p>maven</p>
<ul>
<li><p>maven中版本信息父工程中都有，自己可配置进行覆盖</p>
</li>
<li><p>有的依赖都是starter开头，会自动引入其他所需要的相关依赖</p>
<ul>
<li>starter也会自动引入自动配置类(XXXautoconfigure的Jar包)：不用就别引入——比如mybatis就会自动配置DS、SqlFactory、Mapper等，但是如果没有就不会配置成功</li>
</ul>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805100307261.png" alt="image-20230805100307261"></p>
</li>
<li><p>可以不用starter自己按照旧版本配置，但是没必要</p>
</li>
</ul>
</li>
</ul>
<p>配置文件：放在resource中，application.yml&#x2F;application.properties</p>
<ul>
<li><p>YML</p>
<ul>
<li><p>Key：Value代替property的Key &#x3D; Value</p>
</li>
<li><p>只能用空格缩进，几个无所谓，对齐的就是一级</p>
</li>
<li><p><code>冒号、换行、空格</code>替换property中的一个点</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805101922978.png" alt="image-20230805101922978"></p>
</li>
</ul>
</li>
</ul>
<h2 id="🚀配置文件"><a href="#🚀配置文件" class="headerlink" title="🚀配置文件"></a>🚀配置文件</h2><ul>
<li><p>配置类</p>
<ul>
<li><p>要把spring改成cskaoyan和上面的yml对相应奥</p>
</li>
<li><p>利用反射直接赋值</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805102214618.png" alt="image-20230805102214618"></p>
</li>
<li><p>进阶版本，用到了CP注解中的prefix</p>
</li>
<li><p>需要用set方法赋值，我们用@Data给他set方法</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805102737720.png" alt="image-20230805102737720"></p>
</li>
<li><p>👆属性配置，有点像POJO，没必要放到属性里👇</p>
</li>
<li><p>写在实体对象中，在配置类中直接按照<strong>组件</strong>读取该封装的实体对象即可，比较顺眼</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805103414661.png" alt="image-20230805103414661"></p>
<p>  方式4和方式三（只用Component注解）</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805103954353.png" alt="image-20230805103954353"></p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805103528882.png" alt="image-20230805103528882"></p>
</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="🚀对Web支持"><a href="#🚀对Web支持" class="headerlink" title="🚀对Web支持"></a>🚀对Web支持</h2><ul>
<li><p>静态资源处理</p>
<ul>
<li><p>方式一处理多种映射规则</p>
<p>  <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805110837151.png" alt="image-20230805110837151"></p>
</li>
<li><p>方式二只能一组规则</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805110850050.png"></p>
</li>
</ul>
</li>
<li><p>改应用名、端口号</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805111049693.png" alt="image-20230805111049693"></p>
</li>
<li><p>配置Filter</p>
<ul>
<li><p>自定义继承自</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805111742104.png" alt="image-20230805111742104"></p>
</li>
<li><p>web配置类注册</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805111748727.png" alt="image-20230805111748727"></p>
</li>
</ul>
</li>
<li><p>、</p>
</li>
</ul>
<h2 id="🚀整合Mybatis"><a href="#🚀整合Mybatis" class="headerlink" title="🚀整合Mybatis"></a>🚀整合Mybatis</h2><ul>
<li><p>starter版依赖</p>
</li>
<li><p>配置文件</p>
<ul>
<li><p>先注册再启动</p>
</li>
<li><p>datasource、SqlsessionFactory、MapperSacnConfig，<strong>其中DS和Mapper中有需要自己写的信息</strong></p>
</li>
<li><p><strong>1、在配置文件中设置数据源</strong></p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805112259170.png" alt="image-20230805112259170"></p>
</li>
</ul>
</li>
<li><p>Mapper接口，已经自动配置MapperScanConfiger</p>
<ul>
<li><p><strong>2、需要自己写扫描区域，在SpringBoot启动类里加</strong></p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230805112709725.png" alt="image-20230805112709725"></p>
</li>
</ul>
</li>
<li><p>事务也是自动配置，直接在需要的地方加@Transactional就行</p>
</li>
</ul>
<h1 id="🧠理解"><a href="#🧠理解" class="headerlink" title="🧠理解"></a>🧠理解</h1><h2 id="🧠Spring-读注解"><a href="#🧠Spring-读注解" class="headerlink" title="🧠Spring 读注解"></a>🧠Spring 读注解</h2><blockquote>
<p>Spring读取注解和处理注解配置的流程大致如下:</p>
<ol>
<li><p>Spring在初始化时会通过ClassPathScanningCandidateComponentProvider扫描指定的packages路径,查找带有@Component等注解的类。</p>
</li>
<li><p>扫描到的类信息被封装为BeanDefinition对象,包含了该类的注解信息。并保存到容器的一个ConcurrentHashMap中。</p>
</li>
<li><p>Spring将特定函数的注解如@Bean&#x2F;@Import解析为ImportBeanDefinitionRegistrar对象。</p>
</li>
<li><p>通过调用实现了BeanFactoryPostProcessor接口的类进行后处理。这些处理器可以进一步处理注解。</p>
</li>
<li><p>当请求一个Bean时,如果该Bean依赖其他Bean,会先初始化依赖的Bean。</p>
</li>
<li><p>通过PostProcessor等可以对Bean进行后置处理。</p>
</li>
<li><p>最终容器会调用Bean的初始化方法并将其实例化。</p>
</li>
<li><p>依赖注入Implemented by constructing method parameters to match the requested beans</p>
</li>
</ol>
<p>所以Spring通过扫描、解析注解形成Bean定义信息,并在后处理阶段进一步处理,最终实例化Bean并建立起依赖关系。这是一个渐进式的过程。</p>
</blockquote>
<p>配置Filter的流程</p>
<blockquote>
<p>Spring容器调用Filter的大致流程如下:</p>
<ol>
<li><p>DispatcherServlet在初始化时会从Spring容器中查找实现了Filter接口的Bean。</p>
</li>
<li><p>DispatcherServlet会根据@WebFilter注解上的urlPatterns将Filter映射到指定的路径。</p>
</li>
<li><p>在DispatcherServlet处理请求时,会先调用映射到该请求路径的Filter链。</p>
</li>
<li><p>Spring容器将管理Filter的整个生命周期,负责实例化、调用以及销毁Filter Bean。</p>
</li>
<li><p>FilterChain会按照定义顺序调用Filter的doFilter方法。</p>
</li>
<li><p>在doFilter方法中,Filter可以对request和response进行处理。</p>
</li>
<li><p>处理完成后需要调用chain.doFilter方法将请求转发给下一个Filter。</p>
</li>
<li><p>最后通过FilterChain执行目标资源的服务方法。</p>
</li>
<li><p>响应返回时会按倒序经过Filter链的doFilter方法。</p>
</li>
<li><p>Spring容器也会管理Filter的异步执行方式。</p>
</li>
</ol>
<p>所以Spring容器负责初始化Filter、管理生命周期并调用,Filter则专注请求的预处理和后处理逻辑。两者协同完成整个过滤流程。</p>
</blockquote>
<h2 id="🧠SpringBoot思想"><a href="#🧠SpringBoot思想" class="headerlink" title="🧠SpringBoot思想"></a>🧠SpringBoot思想</h2><blockquote>
<p>Spring Boot自动配置的根本逻辑和思路可以归纳如下:</p>
<ol>
<li>条件化配置</li>
</ol>
<p>根据项目中类路径下是否存在某个类或条件,决定是否装配配置Bean。</p>
<ol start="2">
<li>启动器依赖</li>
</ol>
<p>启动器依赖可以自动导入常用模块配置,简化配置。</p>
<ol start="3">
<li>贴合惯例配置</li>
</ol>
<p>自动配置会按照大多数项目的默认需求进行配置,并可以通过配置文件改变。</p>
<ol start="4">
<li>适配平台差异</li>
</ol>
<p>自动配置会根据不同环境、平台进行适配,如在Web环境中配置MVC相关Bean。</p>
<ol start="5">
<li>外部化配置</li>
</ol>
<p>自动配置的Bean可以通过配置文件或YAML对属性值进行外部化配置。</p>
<ol start="6">
<li>编程式配置</li>
</ol>
<p>可以通过@ConditionalOnMissingBean等注解编程式覆盖或新增配置。</p>
<ol start="7">
<li>自动装配原理</li>
</ol>
<p>实现了xxxAutoConfiguration的自动配置类,注册组件。</p>
<ol start="8">
<li>自动启用功能</li>
</ol>
<p>使用@Enable模块驱动,实现自动装配给定模块的配置。</p>
<p>综上,Spring Boot自动配置的核心是约定优于配置,根据项目情况智能装配组件,可以减少冗余配置代码。</p>
</blockquote>
<h2 id="🧠你会用AOP吗"><a href="#🧠你会用AOP吗" class="headerlink" title="🧠你会用AOP吗"></a>🧠你会用AOP吗</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>AOP使用场景：</p>
<ol>
<li>性能监控：监控应用程序执行时长耗时</li>
<li>事务管理：@Transactional注解</li>
<li>日志处理：利用切面向数据库中插入日志操作</li>
<li>数据校验：利用切面结合[🛠️Hibernate Validator](#🛠️Hibernate Validator)来进行参数校验</li>
<li>认证鉴权： <a name="shiro注解鉴权_1" href="#shiro注解鉴权_2"><strong>shiro注解鉴权</strong></a>时，定义了AuthorizationAttributeSourceAdvisor切面，来查询用户所具备的权限信息；与收集到的@RequiresPermissions注解结合，判断当前请求地址需要的权限信息当前用户是否具备，如果具备，则调用handle方法；如果不具备，则无法调用</li>
<li>缓存处理：可以将查询数据库得到的数据进一步放入到redis中进行缓存</li>
</ol>
<h3 id="🧠为什么需要多线程？"><a href="#🧠为什么需要多线程？" class="headerlink" title="🧠为什么需要多线程？"></a>🧠为什么需要多线程？</h3><blockquote>
<p>面向切面编程(AOP)中的常见多线程使用场景:</p>
<ol>
<li>前置通知和后置通知中的日志记录、性能监控等操作,可以 使用异步方式避免影响主业务逻辑的执行。</li>
<li>方法执行时间过长的业务逻辑,可以抽取出来使用多线程异步执行,避免阻塞。</li>
<li>事务处理中根据不同业务采取不同的隔离级别和传播行为,可以根据需要使用异步或多线程方式。</li>
<li>一些与主业务逻辑无强绑定关系的服务,可以异步调用提高响应速度。</li>
</ol>
<p>在多线程场景下,线程池的线程分配原则:</p>
<ol>
<li>根据系统的性能配置合理预估线程池大小。</li>
<li>为确保服务质量,主业务逻辑任务可以分配专用线程池。</li>
<li>异步或辅助性任务可以共用线程池,并限制其线程数。</li>
<li>对于IO密集型任务,可以采用IO密集型线程池,避免占用过多资源。</li>
<li>可以采用优先级和任务拒绝策略来处理不同类型任务。</li>
<li>监控线程池运行指标,根据负载动态调整配置。</li>
</ol>
<p>所以AOP应采取合理的多线程设计,进行线程池隔离和优化配置,在满足业务需求的前提下,提高系统的并发性能。</p>
</blockquote>
<h2 id="🧠Spring-Servlet"><a href="#🧠Spring-Servlet" class="headerlink" title="🧠Spring&amp;Servlet"></a>🧠Spring&amp;Servlet</h2><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230806164431069.png" alt="image-20230806164431069"></p>
<p>可以在Maven中设置，关闭默认tomcat，使用undertow</p>
<h3 id="🧠SpringBoot文件上传"><a href="#🧠SpringBoot文件上传" class="headerlink" title="🧠SpringBoot文件上传"></a>🧠SpringBoot文件上传</h3><p>存在依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>multipartfile.transferto源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferTo</span><span class="params">(File dest)</span> <span class="keyword">throws</span> IOException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isAvailable()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;File has already been moved - cannot be transferred again&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dest.exists() &amp;&amp; !dest.delete()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Destination file [&quot;</span> + dest.getAbsolutePath() + <span class="string">&quot;] already exists and could not be deleted&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.fileItem.write(dest);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> <span class="string">&quot;transferred&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.fileItem.isInMemory()) &#123;</span><br><span class="line">                    action = <span class="built_in">this</span>.isAvailable() ? <span class="string">&quot;copied&quot;</span> : <span class="string">&quot;moved&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                logger.debug(<span class="string">&quot;Multipart file &#x27;&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;&#x27; with original filename [&quot;</span> + <span class="built_in">this</span>.getOriginalFilename() + <span class="string">&quot;], stored &quot;</span> + <span class="built_in">this</span>.getStorageDescription() + <span class="string">&quot;: &quot;</span> + action + <span class="string">&quot; to [&quot;</span> + dest.getAbsolutePath() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileUploadException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var3.getMessage(), var3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | IllegalStateException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File transfer failed&quot;</span>, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🧠共享数据域"><a href="#🧠共享数据域" class="headerlink" title="🧠共享数据域"></a>🧠共享数据域</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230806154346370.png" alt="image-20230806154346370"></p>
<h3 id="🧠Listener-Filter"><a href="#🧠Listener-Filter" class="headerlink" title="🧠Listener&amp;Filter"></a>🧠Listener&amp;Filter</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230806164310653.png" alt="image-20230806164310653"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230806164252682.png" alt="image-20230806164252682"></p>
<h4 id="F获取配置信息"><a href="#F获取配置信息" class="headerlink" title="F获取配置信息"></a>F获取配置信息</h4><p>Listener</p>
<p>如果要在Filter执行之前读取配置文件并存到公共域对象中,可以通过以下两种方式:</p>
<ol>
<li>使用ServletContextListener</li>
</ol>
<p>由于ServletContextListener会先于Filter被初始化,可以在contextInitialized方法中读取配置,并存入ServletContext域对象中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">config</span> <span class="operator">=</span> <span class="comment">//读取配置</span></span><br><span class="line">    sce.getServletContext().setAttribute(<span class="string">&quot;config&quot;</span>, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用Spring的监听器</li>
</ol>
<p>实现ApplicationListener接口,监听ContextRefreshedEvent事件。该事件会先于Filter执行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 读取配置信息 </span></span><br><span class="line">    applicationContext.setAttribute(<span class="string">&quot;config&quot;</span>, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这样Filter初始化时就可以从ServletContext或Spring上下文对象中获取已存入的配置信息了。</p>
<h4 id="F返回信息方式"><a href="#F返回信息方式" class="headerlink" title="F返回信息方式"></a>F返回信息方式</h4><p>原来直接resp.getWriter就行了</p>
<h1 id="🛠️配置"><a href="#🛠️配置" class="headerlink" title="🛠️配置"></a>🛠️配置</h1><h2 id="🛠️Git相关"><a href="#🛠️Git相关" class="headerlink" title="🛠️Git相关"></a>🛠️Git相关</h2><p>忽略application.yml，因为每个人的路径配置可能不同</p>
<p>或者：单独把个人配置写在另一个yml中，在主yml中声明一下</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807094711697.png" alt="image-20230807094711697"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807094850991.png" alt="image-20230807094850991"></p>
<h2 id="🛠️导包："><a href="#🛠️导包：" class="headerlink" title="🛠️导包："></a>🛠️导包：</h2><p>三步</p>
<ol>
<li><p>xxx。starter</p>
<p> mvn中搜，导pom</p>
</li>
<li><p>搜配置</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807101003005.png" alt="image-20230807101003005"></p>
</li>
</ol>
<h2 id="🛠️小程序"><a href="#🛠️小程序" class="headerlink" title="🛠️小程序"></a>🛠️小程序</h2><h3 id="不用CrossFilter"><a href="#不用CrossFilter" class="headerlink" title="不用CrossFilter"></a>不用CrossFilter</h3><h3 id="没法使用Cookie—-Session"><a href="#没法使用Cookie—-Session" class="headerlink" title="没法使用Cookie—&gt;Session"></a>没法使用Cookie—&gt;Session</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807101647110.png" alt="image-20230807101647110"></p>
<ol>
<li>之前用会话技术实现</li>
</ol>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807102353940.png" alt="image-20230807102353940"></p>
<ol start="2">
<li>现在cookie没法用了</li>
</ol>
<blockquote>
<p>我们自己实现cookie：它的作用就是返回session的位置信息。</p>
<p>服务端维护一个sessionMap，其中有session的信息</p>
<ol>
<li>“服务器”通过响应Body中的“token”发session的信息</li>
<li>“客户端”通过对应的</li>
</ol>
</blockquote>
<h2 id="🛠️Shiro安全框架"><a href="#🛠️Shiro安全框架" class="headerlink" title="🛠️Shiro安全框架"></a>🛠️Shiro安全框架</h2><blockquote>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>登录认证——》授权管理</p>
<h3 id="数据库设计之RoleBasedAccessControl"><a href="#数据库设计之RoleBasedAccessControl" class="headerlink" title="数据库设计之RoleBasedAccessControl"></a>数据库设计之RoleBasedAccessControl</h3><p>基于角色的访问控制：</p>
<p>三张表：</p>
<p>用户、角色、权限</p>
<p>接口很多限制不过来，直接将用户账号和角色进行绑定，相当于：</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807103805822.png" alt="image-20230807103805822"></p>
<p>都是<strong>多对多</strong>的<strong>多表联查</strong>，按照数据库设计范式，应该还有一个关系中间表。</p>
<p>但是在用户中引入一个RoleID联系角色表，<strong>其存储的是JSON字符串</strong>，使用TypeHandler进行类型转换和关联</p>
<p>权限表和角色表也是多对多关系：按照数据库设计范式是有：角色表、关系表、权限表。这里没有设计<strong>全部权限表</strong>，只有<strong>角色和权限的对应关系表</strong>：因为全部权限是要和Controller相关的，而Controller可能随时变化</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807110050259.png" alt="image-20230807110050259"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807104622448.png" alt="image-20230807104622448"></p>
</blockquote>
<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul>
<li>认证、授权（授权+鉴权）、会话管理</li>
<li>三块代码</li>
</ul>
<h3 id="架构："><a href="#架构：" class="headerlink" title="架构："></a>架构：</h3><ul>
<li>Subject<ul>
<li>认证<strong>主体</strong>，提交人</li>
<li>可以是：机器人、脚本、真人操作的客户端</li>
</ul>
</li>
<li>Principal<ul>
<li>身份标识，唯一性，可有多个，但是得有一个主键Principal的“用户名”</li>
</ul>
</li>
<li>Credentials<ul>
<li>证明、凭证，只有主体知道的“密码”</li>
</ul>
</li>
<li><strong>SecurityManager</strong><ul>
<li>安全管理器：</li>
<li>第一手接受处理所有的安全相关请求</li>
<li>管理所有的Subject</li>
<li>内嵌了：以下两个A和<strong>SessionManager</strong>实现会话管理</li>
</ul>
</li>
<li>Authenticator<ul>
<li>认证器：</li>
<li>负责认证操作（用户提交和真实数据的比较）</li>
<li>为了实现以上操作需要两手：一边拿真实数据，一边拿Manager传入</li>
</ul>
</li>
<li>Authorizer<ul>
<li>授权器：</li>
<li>决定：是否有</li>
</ul>
</li>
<li>Realm<ul>
<li>领地：</li>
<li>持有真实的用户名密码</li>
<li>数据来源：配置文件、数据库、内存(Redis)…</li>
</ul>
</li>
</ul>
<h3 id="案例1：认证流程"><a href="#案例1：认证流程" class="headerlink" title="案例1：认证流程"></a>案例1：认证流程</h3><blockquote>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807112408592.png" alt="image-20230807112408592"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807112403198.png" alt="image-20230807112403198"></p>
</blockquote>
<h3 id="案例2：认证，但自己写Realm"><a href="#案例2：认证，但自己写Realm" class="headerlink" title="案例2：认证，但自己写Realm"></a>案例2：认证，但自己写Realm</h3><blockquote>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807112955216.png" alt="image-20230807112955216"></p>
</blockquote>
<ol>
<li><p>shiro.ini（之后不用这种方式）</p>
<p> 写自己的realm的路径和一个${}</p>
</li>
<li><p>realm包中</p>
<ol>
<li>一个给认证器调用的两个方法</li>
<li><strong>token</strong>是一样的，连接传递来自Manager的<strong>用户输入数据</strong></li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807113144920.png" alt="image-20230807113144920"></p>
<ol start="3">
<li>使用service层从数据库中调数据</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807113907698.png" alt="image-20230807113907698"></p>
<ol start="4">
<li>认证操作完整版本realm</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807144506680.png" alt="image-20230807144506680"></p>
</li>
<li><p>主<strong>授权</strong>类，模拟登录，token持有用户输入密码</p>
<blockquote>
<p>自己要写的主要就是Subject.login(token)</p>
<p>以及自己自定义的realm</p>
<p>上面的token是一个封装类型，也就是一个接口，其的各种实现就是各种形式的密码：生物特征、邮箱、自定义、文字。。。等</p>
</blockquote>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807113227113.png" alt="image-20230807113227113"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807114112962.png" alt="image-20230807114112962"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807144836689.png" alt="image-20230807144836689"></p>
</li>
</ol>
<h3 id="案例3：鉴权"><a href="#案例3：鉴权" class="headerlink" title="案例3：鉴权"></a>案例3：鉴权</h3><blockquote>
<p>流程：看有没有角色</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807115223036.png" alt="image-20230807115223036"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807115256705.png" alt="image-20230807115256705"></p>
</blockquote>
<ol>
<li><p>根本类中：Subject.isPromitered</p>
<ol>
<li>注意：<ol>
<li>先验票（看有无角色）再鉴权（看你是什么级别的会员）</li>
</ol>
</li>
<li>底层<br> 1. </li>
<li>自己写</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807144743404.png" alt="image-20230807144743404"></p>
</li>
<li><p>realm中：</p>
<ol>
<li>上面认证中的：</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807144555770.png" alt="image-20230807144555770"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807145101450.png" alt="image-20230807145101450"></p>
<ol start="2">
<li>需要注意的方法</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807144636189.png" alt="image-20230807144636189"></p>
<ol start="3">
<li>完整版本realm</li>
</ol>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807144803049.png" alt="image-20230807144803049"></p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>以上是SE中认证、鉴权流程的基础，总体来说就是将输入的和保存的进行比对</p>
</blockquote>
<h3 id="EE的Web流程"><a href="#EE的Web流程" class="headerlink" title="EE的Web流程"></a>EE的Web流程</h3><blockquote>
<p>Filter：对所有请求进行拦截</p>
<p>Filter中的Map：url——权限Map</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807145633439.png" alt="image-20230807145633439"></p>
</blockquote>
<h3 id="Spring整合Shiro："><a href="#Spring整合Shiro：" class="headerlink" title="Spring整合Shiro："></a>Spring整合Shiro：</h3><blockquote>
<ol>
<li><p>如上，需要注册的组件：</p>
<p> ShiroFilter</p>
<p> SecurityManager</p>
<p> Realm</p>
<p> SessionManager</p>
</li>
<li><p>流程：👇</p>
</li>
</ol>
</blockquote>
<ul>
<li><p>导入依赖：</p>
<ul>
<li>不要starter</li>
<li><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807150231911.png" alt="image-20230807150231911"></li>
</ul>
</li>
<li><p>配置类：</p>
<p>  - </p>
<pre><code>  ![image-20230807150618896](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807150618896.png)
</code></pre>
<ul>
<li><p>ShiroConfig中注册一个filter</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807151043044.png" alt="image-20230807151043044"></p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807151216633.png" alt="image-20230807151216633"></p>
</li>
<li><p>shit没听，下午第一节</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807151524223.png" alt="image-20230807151524223"></p>
</li>
</ul>
</li>
<li><p>controller中的登录：包含认证、鉴权</p>
<ul>
<li><p>认证：</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807152437402.png" alt="image-20230807152437402"></p>
<blockquote>
<p>目前还没改Shiro默认传递请求头还是用cookie，所以小程序不能</p>
<p>但Shiro可以从别的类型请求头中获取数据，不止于cookie</p>
<ul>
<li><p>去cookie化：自定义getSessionId方法：</p>
<p>  cookie就是客户端服务器间交流中承载SessionID的，我们重写getSessionId()方法，用自己的方式传递SessionID</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807153318465.png" alt="image-20230807153318465"></p>
</li>
<li><p>小程序登录controller</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807160454470.png" alt="image-20230807160454470"></p>
</li>
<li><p>从网页到上面的controller👆，以上getSession就是获取请求中的自定义sessionID“Token”</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807161037315.png" alt="image-20230807161037315"></p>
<p>  <img src="C:/Users/何/AppData/Roaming/Typora/typora-user-images/image-20230807161041776.png" alt="image-20230807161041776"></p>
<p>  最终版自定义getSessionId</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/image-20230807161321622.png" alt="image-20230807161321622"></p>
</li>
</ul>
</blockquote>
</li>
<li><p>鉴权：小程序不需要鉴权</p>
<ul>
<li>后端程序中的鉴权操作：起点：</li>
</ul>
</li>
<li><p>ShiroConfig</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807162437393.png" alt="image-20230807162437393"></p>
</li>
<li><p>controller取到注</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807162329110.png" alt="image-20230807162329110"></p>
</li>
<li><p>realm本地数据获取鉴权信息</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807162304659.png" alt="image-20230807162304659"></p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807162309513.png" alt="image-20230807162309513"></p>
</li>
<li><p>Shiro配置类需要的自定义类</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807162632525.png" alt="image-20230807162632525"></p>
</li>
</ul>
<p>  没登陆之前访问info无法，登陆后就可以</p>
</li>
</ul>
<h3 id="更进一步：注解方式标定"><a href="#更进一步：注解方式标定" class="headerlink" title="更进一步：注解方式标定"></a>更进一步：注解方式标定</h3><p>也就是 <a name="shiro注解鉴权_2" href="#shiro注解鉴权_1"><strong>shiro注解鉴权</strong></a></p>
<blockquote>
<p>标定需要认证&#x2F;鉴权的Controller的urlPattern。省去在shiroFilter中加条目</p>
</blockquote>
<ol>
<li><p>导入Maven包</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure>

</li>
<li><p>配置类中加组件于ShiroConfig中：</p>
<p> 就可以把其他的删掉了</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807163858705.png" alt="image-20230807163858705"></p>
</li>
<li><p>@requestMapping上加：</p>
<ul>
<li><p>@RequirePermissions</p>
<p>  <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807163829859.png" alt="image-20230807163829859"></p>
</li>
<li><p>@RequireAuthentications</p>
</li>
</ul>
</li>
<li><p>原理：</p>
<p> AOP</p>
</li>
</ol>
<h2 id="🛠️Hibernate-validator参数校验"><a href="#🛠️Hibernate-validator参数校验" class="headerlink" title="🛠️Hibernate validator参数校验"></a>🛠️Hibernate validator参数校验</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>导入依赖</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808093450398.png" alt="image-20230808093450398"></p>
</li>
<li><p>使用注解</p>
<p> 一些注解参数</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808094238291.png" alt="image-20230808094238291"></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808094311852.png" alt="image-20230808094311852"></p>
<p> 属性+传入参数（key-Value）加注解</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808094613394.png" alt="image-20230808094613394"></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808094606999.png" alt="image-20230808094606999"></p>
<p> Post请求体参数判断：</p>
<p> <strong>别用Map接收，因为在Domain属性中设置过滤条件，不用它接收的话就无法过滤了</strong></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808094943884.png" alt="image-20230808094943884"></p>
</li>
<li><p>如何返回对应的</p>
</li>
</ol>
<p>  ​    </p>
<pre><code>![image-20230808095412808](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808095412808.png)

![image-20230808095408797](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808095408797.png)

改进：

1. 工具类

    &gt; 
    &gt;
    &gt; ![image-20230808100054585](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808100054585.png)
    &gt;
    &gt; ![image-20230808100013796](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808100013796.png)

2. 抛异常

    &gt; **不用接受返回结果判断**
    &gt;
    &gt; ![image-20230808100220881](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808100220881.png)
    &gt;
    &gt; ![image-20230808100225072](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808100225072.png)
    &gt;
    &gt; 设置全局异常处理器，精准问题，自定义异常
    &gt;
    &gt; ![](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808100225072.png)
    &gt;
    &gt; ![image-20230808100515485](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808100515485.png)
    &gt;
    &gt; 返回值JSON形式、异常处理器
    &gt;
    &gt; ![image-20230808100749793](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808100749793.png)
    &gt;
    &gt; ![image-20230808100952887](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808100952887.png)

3. AOP切面

    &gt; 1. 自定义个注解，不用多整
    &gt;
    &gt;     ![image-20230808101619966](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808101619966.png)
    &gt;
    &gt; 2. 定义handler
    &gt;
    &gt;     ![image-20230808101552435](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808101552435.png)
    &gt;
    &gt; 3. 定义切面
    &gt;
    &gt;     ![image-20230808101556472](![](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808101556472.png)
</code></pre>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>实现参数校验和业务代码的分离</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230808102225566.png" alt="image-20230808102225566"></p>
</blockquote>
<ol>
<li>在domain中通过注解设置校验</li>
<li>在handler中设置参数校验，设置“不规范异常”可进入方法内</li>
<li>自定义异常，关联全局异常处理，用于传入参数不规范时分类处理返回提示之类</li>
<li>Util</li>
<li>AOP切handler，进行前置通知，通过相关Util调用异常执行</li>
</ol>
<h2 id="🛠️云服务"><a href="#🛠️云服务" class="headerlink" title="🛠️云服务"></a>🛠️云服务</h2><h3 id="对象云存储OSS"><a href="#对象云存储OSS" class="headerlink" title="对象云存储OSS"></a>对象云存储OSS</h3><h3 id="短信服务SMS验证码"><a href="#短信服务SMS验证码" class="headerlink" title="短信服务SMS验证码"></a>短信服务SMS验证码</h3><h3 id="以上的Spring整合"><a href="#以上的Spring整合" class="headerlink" title="以上的Spring整合"></a>以上的Spring整合</h3><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230809110714462.png" alt="image-20230809110714462"></p>
<h4 id="https"><a href="#https" class="headerlink" title="https"></a>https</h4><p>非对称+对称</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgtypora_imgimage-20230809124526279.png" alt="image-20230809124526279"></p>
<p>第五步：用非对称加密，服务器针对客户端生成私钥，只有他俩知道</p>
<p>第七步：用对称加密</p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230809112728649.png" alt="image-20230809112728649"></p>
<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230809112810554.png" alt="image-20230809112810554"></p>
<blockquote>
<ol>
<li>结果如一</li>
<li>雪崩：一处变处处便</li>
<li>防止冲突</li>
</ol>
</blockquote>
<p>单向，无法逆向解码，不可能还原，不能算加密</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230809111519769.png" alt="image-20230809111519769"></p>
<p>可以进行验证</p>
<h5 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h5><p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230809111937153.png" alt="image-20230809111937153"></p>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230809112635703.png" alt="image-20230809112635703"></p>
<h3 id="以上整合Spring"><a href="#以上整合Spring" class="headerlink" title="以上整合Spring"></a>以上整合Spring</h3><p>MD5设置加密</p>
<ol>
<li><p>倒依赖</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230809112955712.png" alt="image-20230809112955712"></p>
</li>
<li><p>使用：</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230809113035355.png" alt="image-20230809113035355"></p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230809113405295.png" alt="image-20230809113405295"></p>
<p> 多种散列算法：</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230809113713985.png" alt="image-20230809113713985"></p>
</li>
</ol>
<h1 id="项目一总结"><a href="#项目一总结" class="headerlink" title="项目一总结"></a>项目一总结</h1><p>总结了第一个EE项目的整体思路</p>
<h2 id="推广管理"><a href="#推广管理" class="headerlink" title="推广管理"></a>推广管理</h2><h3 id="推广管理-整体"><a href="#推广管理-整体" class="headerlink" title="推广管理-整体"></a>推广管理-整体</h3><p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230722202540112.png" alt="image-20230722202540112"></p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230727093911162.png" alt="image-20230727093911162"></p>
<p>命名规则：三层：属于谁，叫什么，干什么</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230722230745458.png" alt="image-20230722230745458"></p>
<p>单纯点击访问👆</p>
<p>数据库表</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723121928721.png" alt="image-20230723121928721"></p>
<p>从登录一路点过来：</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723162349112.png" alt="image-20230723162349112"></p>
<blockquote>
<p>虽然是三个不同的区域管理，实现的功能具体到方法无非就是增删改查</p>
<p>设计就从：关键还是SQL语句，所有的一切都服务于SQL</p>
<ol>
<li>请求数据（接收-格式）</li>
<li>处理（controller接收数据-JSON转java基本类型、转service实现数据操作sql语句逻辑、dao被调用-domain、mapper的方法）</li>
<li>响应数据（生成-格式）</li>
</ol>
<p>为什么要有Service层：，同一个接口会有不同的实现方式：多种impl</p>
<p>一个关键需求：要求的层级关系返回值，数据库中的数据都是平级的单条数据：</p>
<ol>
<li><p>实现1：多条sql语句：mybatis的多表查询：自己在对应的Mapper中加语句</p>
</li>
<li><p>实现2：用java集合类+三层循环</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230724103110115.png" alt="image-20230724103110115"></p>
</li>
<li><p>实现3：Java+MySql</p>
</li>
<li><p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230724100603262.png" alt="image-20230724100603262"></p>
</li>
</ol>
<hr>
<p>MyBatis Generator生成类执行CRUD操作的调用链:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[Service] --&gt; B[DAO]</span><br><span class="line">B --&gt; C[Mapper]</span><br><span class="line">C --&gt; D[SQL]</span><br><span class="line">D --&gt; E[Database]</span><br><span class="line"></span><br><span class="line">classDef grey fill:#ddd,stroke:#fff,stroke-width:2px;</span><br><span class="line">class A,E grey</span><br></pre></td></tr></table></figure>

<p>代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">//模型类</span></span><br><span class="line">userMapper.insert(user); <span class="comment">//Mapper接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删 </span></span><br><span class="line"><span class="type">UserExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserExample</span>(); <span class="comment">//Example类</span></span><br><span class="line">example.createCriteria().andIdEqualTo(<span class="number">1</span>);</span><br><span class="line">userMapper.deleteByExample(example);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line"><span class="type">User</span> <span class="variable">updateUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">updateUser.setId(<span class="number">1</span>);</span><br><span class="line">userMapper.updateByPrimaryKey(updateUser); </span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>流程说明:</p>
<ul>
<li>Service层调用DAO层 </li>
<li>DAO实现类调用Mapper接口</li>
<li>Mapper接口执行SQL语句</li>
<li>SQL操作数据库完成CRUD</li>
</ul>
<p>可以看到代码调用链从Service到数据库,利用生成类可以高效实现CRUD操作。</p>
</blockquote>
<h4 id="controller主要负责："><a href="#controller主要负责：" class="headerlink" title="controller主要负责："></a>controller主要负责：</h4><ol>
<li><p>接收请求信息，造Bean对象（由Generator创建的和数据库表对应的Bean类）</p>
<blockquote>
<ol>
<li>对数据库有修改的一般是Post请求，只是查看的是Get请求</li>
<li>Post请求需要在请求体中获取信息，因为传来的JSON信息，需要用到<strong>JacksonUtil</strong>进行类型转换，有两种思路：<ol>
<li>逐条获取并转换参数，有基础类型和其他类型两种写法</li>
<li>先得到请求体后利用ObjectMapper整体转换，与上相比需要多创建一个对象，在传入参数较多的情况下使用比较方便</li>
</ol>
</li>
<li>Get请求需要从请求头中获取信息，只有req.getParameter一种可用</li>
</ol>
</blockquote>
</li>
<li><p>通过将Bean对象或个别参数 填入 新建Service接口的实现类中，返回值即结果集或处理过的结果</p>
</li>
<li><p>根据需要造返回体，需要<strong>ResponseUtil</strong>形成成功或者失败的响应格式，再用<strong>resp</strong>+<strong>JacksonUtil</strong>输出。如果分多集，可以先用Map&lt;String, Object&gt;的形式将结果集（当个对象或者对象数组或集合）填入对应的“key”中，为了对应JSON格式</p>
</li>
</ol>
<h4 id="service主要负责："><a href="#service主要负责：" class="headerlink" title="service主要负责："></a>service主要负责：</h4><p>接口规定，连接controller和dao层操作</p>
<ol>
<li>需要建立<strong>SqlSession</strong>、相关Bean对象（看SQL的返回结果，如果是增删改可以只设置一个int接收改动行数）及其<strong>Mapper</strong>（其中含有Mybatis-Generator生成的基本SQL操作：增删改查的byExample、byPrimarykey、one等）<ol>
<li>其中如果用到了查询操作需要创建对应对象的<strong>Example</strong>类，其中的criteria内部类负责查询条件的拼接</li>
<li>如果需要多表联查等复杂操作可以自己定义一个Mapper</li>
<li>以上以下涉及的需要依赖注入的部分</li>
</ol>
</li>
<li>最后可根据dao的查询结果返回给controller一个对象</li>
</ol>
<h4 id="dao层主要负责"><a href="#dao层主要负责" class="headerlink" title="dao层主要负责"></a>dao层主要负责</h4><p>本项目的dao层基本上都是MB生成的包括domain、mapper、typehandler，基本上涵盖了所有的dao层操作。比较复杂的多对多的多表联查需要自己设置：VO、BO类、Mapper接口以及对应的Mapper.xml</p>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><h4 id="list方法"><a href="#list方法" class="headerlink" title="list方法"></a>list方法</h4><ol>
<li>思路<ul>
<li>查询广告&#x2F;专题列表,可分页和按条件查询</li>
<li>返回广告&#x2F;专题的简要信息,如ID、名称、状态等</li>
</ul>
</li>
<li>实现<ol>
<li>controller读取Get请求数据：其中包含页数信息参数</li>
<li>service查询，条件中要加入逻辑删除判断</li>
<li></li>
</ol>
</li>
</ol>
<h4 id="create方法"><a href="#create方法" class="headerlink" title="create方法"></a>create方法</h4><ol>
<li><p>思路：</p>
<ul>
<li><p>创建新的广告&#x2F;专题数据</p>
</li>
<li><p>封装广告&#x2F;专题的信息,插入数据库</p>
</li>
<li><p>返回创建成功的广告&#x2F;专题的ID</p>
</li>
</ul>
</li>
<li><p>实现：</p>
<ol>
<li><p>Conroller读取请求中JSON数据：</p>
<ol>
<li><p>如果单条数据，不用建立对象，省事</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> JacksonUtil.parseString(requestBody, <span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
<li><p><a name="如果数据过多，呈对象形式_2" href="#如果数据过多，呈对象形式_1"><strong>如果数据过多，呈对象形式</strong></a></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725134005658.png" alt="image-20230725134005658"></p>
</li>
</ol>
</li>
<li><p>service层中先判断库中是否有存在，没有的话直接insert</p>
<ol>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725195918269.png" alt="image-20230725195918269"></li>
</ol>
</li>
<li><p>回到controller中判断是否返回空值，如果返回值不为空就说明成功</p>
</li>
</ol>
</li>
</ol>
<h4 id="update方法"><a href="#update方法" class="headerlink" title="update方法"></a>update方法</h4><ol>
<li><p>思路</p>
<ul>
<li><p>更新已存在的广告&#x2F;专题数据</p>
</li>
<li><p>根据广告&#x2F;专题ID查找数据,然后更新其属性</p>
</li>
<li><p>如启用&#x2F;禁用广告,修改专题名称等</p>
</li>
</ul>
</li>
<li><p>实现：</p>
<ol>
<li><a name="如果数据过多，呈对象形式_1" href="#如果数据过多，呈对象形式_2"><strong>如果数据过多，呈对象形式</strong></a></li>
<li>将数据判断后将domain对象传给Service实现，一句updateByPrimaryKey搞定</li>
<li>返回前判断</li>
</ol>
</li>
</ol>
<h4 id="delete方法"><a href="#delete方法" class="headerlink" title="delete方法"></a>delete方法</h4><ol>
<li><p>思路</p>
<ul>
<li><p>删除已存在的广告&#x2F;专题数据</p>
</li>
<li><p>根据广告&#x2F;专题ID在数据库中将其标记为删除</p>
</li>
<li><p>批量删除时可传入多个ID进行删除</p>
</li>
</ul>
</li>
<li><p>实现：</p>
<ol>
<li></li>
</ol>
</li>
</ol>
<h4 id="listUser方法"><a href="#listUser方法" class="headerlink" title="listUser方法"></a>listUser方法</h4><ol>
<li><p>思路：</p>
<ul>
<li><p>查询某个优惠券的领取用户列表；</p>
<p>  通过传递优惠券ID,可以查询出所有已经领取这个优惠券的用户信息,包括用户ID、领取时间等。</p>
</li>
<li><p>查询某个用户领取的优惠券列表；</p>
<p>  通过传递用户ID,可以查询出该用户所有的优惠券信息,包括优惠券名称、面值、有效期等。</p>
</li>
<li><p>条件查询用户领取情况：</p>
<p>  可以传入过滤条件,比如领取时间范围、优惠券类型等,查询满足这些条件的用户-优惠券信息。</p>
</li>
<li><p>统计优惠券领取用户数量：</p>
<p>  可以统计某个优惠券被领取的总人数。</p>
</li>
<li><p>分页查询用户领取列表：</p>
<p>  可以对查询结果进行分页,然后返回指定页码的数据。</p>
</li>
<li><p>排序查询用户领取列表：</p>
<p>  可以按一定顺序(时间、字母等)排序返回用户领取的优惠券列表。</p>
</li>
</ul>
</li>
<li><p>实现：</p>
<ol>
<li>123</li>
</ol>
</li>
</ol>
<h3 id="功能实现："><a href="#功能实现：" class="headerlink" title="功能实现："></a>功能实现：</h3><h4 id="ad：广告管理"><a href="#ad：广告管理" class="headerlink" title="ad：广告管理"></a><strong>ad：广告管理</strong></h4><h4 id="list"><a href="#list" class="headerlink" title="list"></a><strong>list</strong></h4><ol>
<li><p>请求响应：</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725144825577.png" alt="image-20230725144825577"></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725150427832.png" alt="image-20230725150427832"></p>
</li>
<li><p>实现</p>
<ol>
<li>在搜索过后没法全部显示</li>
</ol>
</li>
</ol>
<h4 id="create"><a href="#create" class="headerlink" title="create"></a><strong>create</strong></h4><ol>
<li><p>消息：三个分别是：</p>
<p> option、post请求响应、前端生成消息提醒</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723124453794.png" alt="image-20230723124453794"></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726150128954.png" alt="image-20230726150128954"></p>
<p> 请求、响应内容：</p>
<p>  <a name="上传图片：在create之前如果有文件就先上传文件，用admin/storage/create_1" href="#上传图片：在create之前如果有文件就先上传文件，用admin/storage/create_2"><strong>上传图片：在create之前如果有文件就先上传文件，用admin&#x2F;storage&#x2F;create</strong></a></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723125730429.png" alt="image-20230723125730429"></p>
<p> 123</p>
<p> 123</p>
<p> 123</p>
<p> 123</p>
</li>
<li><p>对应数据库内容</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723104528237.png" alt="image-20230723104528237"></p>
</li>
<li><p>流程</p>
 <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgcreate%E6%B5%81%E7%A8%8B.png" alt="create流程" style="zoom:200%;" />

<ul>
<li><p>前端发送上传文件请求</p>
<ul>
<li><span style=color:#34495e;background:#EBFFEB><strong>问题</strong></span>：为什么请求中的url就已经是URL形式，什么时候处理的文件上传？<ul>
<li>有个admin&#x2F;storage&#x2F;create，存图片到wx&#x2F;storage，并且把名字给换了</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器端接收请求并处理文件数据：</p>
<ol>
<li><p>请求体中获取数据，JSON转Java对象</p>
</li>
<li><p>判断内容是否符合要求</p>
<ol>
<li>name、content、url不能为空</li>
<li>图片上传大小、格式限制</li>
</ol>
 <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723122130371.png" alt="image-20230723122130371" style="zoom:33%;" />
</li>
<li><p>进行数据库操作</p>
</li>
</ol>
</li>
<li><p>控制器层与业务层协作保存文件和数据</p>
</li>
<li><p>数据库执行插入操作</p>
</li>
<li><p>返回响应给前端</p>
</li>
</ul>
</li>
</ol>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a><strong>update</strong></h4><ol>
<li><p>请求响应</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723142144075.png" alt="image-20230723142144075"></p>
 <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723142203580.png" alt="image-20230723142203580" style="zoom: 50%;" />
</li>
<li><p>流程:</p>
<p> ​    </p>
<p> ​    </p>
</li>
<li><p>123</p>
</li>
</ol>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a><strong>delete</strong></h4><ol>
<li><p>响应请求：</p>
<ol>
<li>先删除，后展示</li>
</ol>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723110823474.png" alt="image-20230723110823474"></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723110903490.png" alt="image-20230723110903490" style="zoom: 80%;" /><img src="https://gitee.com/EmotionalZ/pic-go/raw/master/img/image-20230723111022855.png" alt="image-20230723111022855" style="zoom: 67%;" /></p>
</li>
<li><p>流程图</p>
 <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgdelete%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="delete流程图" style="zoom:200%;" />

<ul>
<li>前端发送删除请求,请求中包含删除条件</li>
<li>服务器接收请求,控制器层解析请求</li>
<li>业务层处理请求,构建删除条件</li>
<li>调用DAO执行数据库删除操作</li>
<li>数据库根据条件执行DELETE操作</li>
<li>返回响应给前端</li>
<li>前端获取并处理响应</li>
</ul>
</li>
</ol>
<h3 id="coupon：优惠券管理"><a href="#coupon：优惠券管理" class="headerlink" title="coupon：优惠券管理"></a>coupon：优惠券管理</h3><p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723211541172.png" alt="image-20230723211541172"></p>
<h4 id="⭐list"><a href="#⭐list" class="headerlink" title="⭐list"></a>⭐list</h4><ol>
<li><p>请求&#x2F;响应：</p>
<ol>
<li>点击优惠券管理同时发三个GET请求：goods&#x2F;list、coupon&#x2F;list、category&#x2F;list</li>
</ol>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723212950884.png" alt="image-20230723212950884"></p>
</li>
</ol>
<img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723212507589.png" alt="image-20230723212507589"  />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /admin/coupon/list?page=<span class="number">1</span>&amp;limit=<span class="number">20</span>&amp;sort=add_time&amp;order=desc HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>显示刷新过之后新增的没了，可能是create设置的morendelete是true？</li>
</ol>
<h4 id="⭐create"><a href="#⭐create" class="headerlink" title="⭐create"></a>⭐create</h4><ol>
<li><p>请求&#x2F;响应：</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723212907523.png" alt="image-20230723212907523"></p>
 <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723212839260.png" alt="image-20230723212839260" style="zoom:50%;" />

<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230724142643777.png" alt="image-20230724142643777"></p>
<p> 👆一个问题：传入的goodsvalue是字符串，数据库中是Integer[]<em>需要用到mybatis-generator中的typehandler：自定义handler</em>：创建数据</p>
</li>
<li><p>实现</p>
</li>
<li></li>
</ol>
<h4 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h4><ol>
<li>请求响应<ol>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723221410238.png" alt="image-20230723221410238"></li>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723221353847.png" alt="image-20230723221353847" style="zoom: 67%;" /></li>
</ol>
</li>
<li>实现</li>
</ol>
<h4 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h4><ol>
<li>请求响应：<ol>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723221527417.png" alt="image-20230723221527417"></li>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723221602881.png" alt="image-20230723221602881" style="zoom:50%;" /></li>
</ol>
</li>
<li>实现</li>
</ol>
<p>输入id，逻辑删除对应</p>
<h4 id="listuser"><a href="#listuser" class="headerlink" title="listuser"></a>listuser</h4><ol>
<li>业务分析：</li>
</ol>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723174306174.png" alt="image-20230723174306174"></p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723174316807.png" alt="image-20230723174316807"></p>
<p>点击优惠券详情后会发来两个Get请求：<strong>read</strong>（根据ID获取购物券详情）、<strong>listuser</strong>（根据ID+分页信息获取相关User的信息）</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723171930127.png" alt="image-20230723171930127"></p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723174848532.png" alt="image-20230723174848532" style="zoom: 67%;" /><img src="https://gitee.com/EmotionalZ/pic-go/raw/master/img/image-20230723172005113.png" alt="image-20230723172005113" style="zoom: 67%;" /></p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723174420458.png" alt="image-20230723174420458"></p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723174432336.png" alt="image-20230723174432336"></p>
<ol start="2">
<li>实现：<ol>
<li>doGet分发</li>
<li></li>
</ol>
</li>
<li>阿斯顿：</li>
</ol>
<h3 id="topic：专题管理"><a href="#topic：专题管理" class="headerlink" title="topic：专题管理"></a>topic：专题管理</h3><p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723211546586.png" alt="image-20230723211546586"></p>
<h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><ol>
<li><p>请求响应</p>
<p> 123</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725203813099.png" alt="image-20230725203813099"></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725203935029.png" alt="image-20230725203935029"></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725203723022.png" alt="image-20230725203723022"></p>
</li>
<li><p>实现：</p>
<ol>
<li>需要根据其中的goods找goods</li>
</ol>
</li>
</ol>
<h4 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h4><ol>
<li>请求&#x2F;响应：<ol>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723220004739.png" alt="image-20230723220004739"></li>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723220101532.png" alt="image-20230723220101532" style="zoom: 50%;" /><img src="https://gitee.com/EmotionalZ/pic-go/raw/master/img/image-20230723220104669.png" alt="image-20230723220104669" style="zoom:50%;" /></li>
</ol>
</li>
<li>实现：</li>
</ol>
<h4 id="create-1"><a href="#create-1" class="headerlink" title="create"></a>create</h4><ol>
<li><p>请求&#x2F;响应</p>
<ol>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723215149623.png" alt="image-20230723215149623"></li>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723220207766.png" alt="image-20230723220207766"  /></li>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230724195743187.png" alt="image-20230724195743187"></li>
</ol>
</li>
<li><p>实现</p>
<ol>
<li><p>类型转换</p>
<blockquote>
<p>阿斯顿</p>
<p>asd </p>
<p>阿斯顿</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h4 id="update-2"><a href="#update-2" class="headerlink" title="update"></a>update</h4><ol>
<li>请求&#x2F;响应<ol>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723221958478.png" alt="image-20230723221958478"></li>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723221942910.png" alt="image-20230723221942910" style="zoom:67%;" /></li>
</ol>
</li>
<li>实现<ol>
<li></li>
</ol>
</li>
</ol>
<h4 id="delete-2"><a href="#delete-2" class="headerlink" title="delete"></a>delete</h4><ol>
<li>请求&#x2F;响应<ol>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723215642607.png" alt="image-20230723215642607"></li>
<li>多重删除：</li>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723215907436.png" alt="image-20230723215907436"></li>
</ol>
</li>
<li>实现</li>
</ol>
<h2 id="个人接口"><a href="#个人接口" class="headerlink" title="个人接口"></a>个人接口</h2><h3 id="商城管理"><a href="#商城管理" class="headerlink" title="商城管理"></a>商城管理</h3><p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723191832445.png" alt="image-20230723191832445"></p>
<h4 id="admin-region✅"><a href="#admin-region✅" class="headerlink" title="admin region✅"></a>admin region✅</h4><h5 id="多表查询-list"><a href="#多表查询-list" class="headerlink" title="多表查询 list"></a>多表查询 list</h5><ol>
<li><p>请求&#x2F;响应</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725214534646.png" alt="image-20230725214534646"></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725214557508.png" alt="image-20230725214557508"></p>
</li>
<li><p>实现：两种思路：区别在service层：</p>
<ol>
<li><p>自己编写SQL语句，多表拼接查询</p>
<ol>
<li><p>使用多表联查</p>
</li>
<li><pre><code class="sql"> &lt;resultMap id=&quot;Map&quot; type=&quot;org.example.zyx.bean.Region&quot;&gt;
         &lt;id column=&quot;province_id&quot; property=&quot;id&quot;/&gt;
         &lt;result column=&quot;province_pid&quot; property=&quot;pid&quot;/&gt;
         &lt;result column=&quot;province_name&quot; property=&quot;name&quot;/&gt;
         &lt;result column=&quot;province_type&quot; property=&quot;type&quot;/&gt;
         &lt;result column=&quot;province_code&quot; property=&quot;code&quot;/&gt;
         &lt;collection property=&quot;children&quot; ofType=&quot;org.example.zyx.bean.Region&quot;&gt;
             &lt;id column=&quot;city_id&quot; property=&quot;id&quot;/&gt;
             &lt;result column=&quot;city_pid&quot; property=&quot;pid&quot;/&gt;
             &lt;result column=&quot;city_name&quot; property=&quot;name&quot;/&gt;
             &lt;result column=&quot;city_type&quot; property=&quot;type&quot;/&gt;
             &lt;result column=&quot;city_code&quot; property=&quot;code&quot;/&gt;
             &lt;collection property=&quot;children&quot; ofType=&quot;org.example.zyx.bean.Region&quot;&gt;
                 &lt;id column=&quot;district_id&quot; property=&quot;id&quot;/&gt;
                 &lt;result column=&quot;district_pid&quot; property=&quot;pid&quot;/&gt;
                 &lt;result column=&quot;district_name&quot; property=&quot;name&quot;/&gt;
                 &lt;result column=&quot;district_type&quot; property=&quot;type&quot;/&gt;
                 &lt;result column=&quot;district_code&quot; property=&quot;code&quot;/&gt;
             &lt;/collection&gt;
         &lt;/collection&gt;
     &lt;/resultMap&gt;
 
     &lt;select id=&quot;selectAll&quot; resultMap=&quot;Map&quot;&gt;
         SELECT *
         FROM (SELECT
                   id as province_id,
                   pid as province_pid,
                   name as province_name,
                   type as province_type,
                   code as province_code
               FROM market_region WHERE type = 1) p
                  LEFT JOIN (SELECT
                                 id as city_id,
                                 pid as city_pid,
                                 name as city_name,
                                 type as city_type,
                                 code as city_code
                             FROM market_region WHERE type = 2) c
                  ON p.province_id = c.city_pid
                  LEFT JOIN (SELECT
                                 id as district_id,
                                 pid as district_pid,
                                 name as district_name ,
                                 type as district_type,
                                 code as district_code
                             FROM market_region WHERE type = 3) d
                  ON d.district_pid = c.city_id
     &lt;/select&gt;
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    2. 多次调用Java中的基础查询对象</span><br><span class="line"></span><br><span class="line">        1. 使用VO+多次查询封装，三重循环</span><br><span class="line">        2. &lt;img src=&quot;https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725223217078.png&quot; alt=&quot;image-20230725223217078&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">### admin order❓</span><br><span class="line"></span><br><span class="line">#### list</span><br><span class="line"></span><br><span class="line">1. **请求/响应**</span><br><span class="line"></span><br><span class="line">    ![image-20230725234547785](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725234547785.png)</span><br><span class="line"></span><br><span class="line">    先Channel（Get）再List（Get）</span><br><span class="line"></span><br><span class="line">    ![image-20230725234631310](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725234631310.png)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    ![image-20230725234814690](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725234814690.png)</span><br><span class="line"></span><br><span class="line">    ![image-20230725235113933](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725235113933.png)</span><br><span class="line"></span><br><span class="line">2. **实现**</span><br><span class="line"></span><br><span class="line">#### detail</span><br><span class="line"></span><br><span class="line">1. **请求/响应**：传来一个OrderID，到MarketOrderGoods里拿订单对应的商品信息，再用OrderID在Order表里找对应的UserID到MarketUser找对应的User</span><br><span class="line"></span><br><span class="line">    ![image-20230725235913679](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725235913679.png)</span><br><span class="line"></span><br><span class="line">    ![image-20230725235939865](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725235939865.png)</span><br><span class="line"></span><br><span class="line">    ![image-20230725235953698](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725235953698.png)</span><br><span class="line"></span><br><span class="line">    ![image-20230726000140047](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726000140047.png)</span><br><span class="line"></span><br><span class="line">    ![image-20230726000322824](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726000322824.png)</span><br><span class="line"></span><br><span class="line">    ![image-20230726000525304](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726000525304.png)</span><br><span class="line"></span><br><span class="line">2. **实现**</span><br><span class="line"></span><br><span class="line">    ​    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### refund</span><br><span class="line"></span><br><span class="line">1. **请求/响应**</span><br><span class="line"></span><br><span class="line">    ​    </span><br><span class="line"></span><br><span class="line">2. **实现**</span><br><span class="line"></span><br><span class="line">#### channel</span><br><span class="line"></span><br><span class="line">1. **请求/响应**</span><br><span class="line"></span><br><span class="line">    ![image-20230727000056929](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230727000056929.png)</span><br><span class="line"></span><br><span class="line">      ![image-20230727000038051](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230727000038051.png)</span><br><span class="line"></span><br><span class="line">2. **实现**</span><br><span class="line"></span><br><span class="line">#### ship</span><br><span class="line"></span><br><span class="line">1. **请求/响应**</span><br><span class="line"></span><br><span class="line">    ![image-20230726200814186](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726200814186.png)</span><br><span class="line"></span><br><span class="line">    ![image-20230726200927220](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726200927220.png)</span><br><span class="line"></span><br><span class="line">2. **实现**</span><br><span class="line"></span><br><span class="line">#### delete</span><br><span class="line"></span><br><span class="line">1. **请求/响应**</span><br><span class="line"></span><br><span class="line">    ![image-20230727000144103](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230727000144103.png)</span><br><span class="line"></span><br><span class="line">      ![image-20230727000125699](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230727000125699.png)</span><br><span class="line"></span><br><span class="line">2. **实现**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 登录登出✅</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20230723191841318](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723191841318.png)</span><br><span class="line"></span><br><span class="line">#### 登录</span><br><span class="line"></span><br><span class="line">构造admin auth login</span><br><span class="line"></span><br><span class="line">1. **请求/响应**</span><br><span class="line">2. **实现**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 信息</span><br><span class="line"></span><br><span class="line">清楚admin auth info</span><br><span class="line"></span><br><span class="line">1. **请求/响应**</span><br><span class="line">2. **实现**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 推广管理✅</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20230723191847328](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723191847328.png)</span><br><span class="line"></span><br><span class="line">#### 优惠券管理</span><br><span class="line"></span><br><span class="line">见上✅</span><br><span class="line"></span><br><span class="line">#### 创建优惠券</span><br><span class="line"></span><br><span class="line">见上✅</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 商品管理✅</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20230723191855177](https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723191855177.png)</span><br><span class="line"></span><br><span class="line">#### 图片上传：admin storage create</span><br><span class="line"></span><br><span class="line">&gt; 效果： &lt;a name=&quot;上传图片：在create之前如果有文件就先上传文件，用admin/storage/create_2&quot; href=&quot;#上传图片：在create之前如果有文件就先上传文件，用admin/storage/create_1&quot;&gt;**上传图片：在create之前如果有文件就先上传文件，用admin/storage/create**&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 思路</span><br><span class="line"></span><br><span class="line">&gt; ```java</span><br><span class="line">&gt; //对象的存储：其实就是文件上传</span><br><span class="line">&gt; //1.进行文件上传；2、将上传的文件信息存储到数据库 3.返回回执信息</span><br><span class="line">&gt; //说明：其中，当前接口需要返回url，也就是商品图片地址链接</span><br><span class="line">&gt; //关于该链接：</span><br><span class="line">&gt; // 1.可以将文件存储在应用根目录，返回一个相对于应用根目录的相对路径，借助于缺省Servlet可以将图片显示出来 http://localhost:80803/image/xxxx.jpg</span><br><span class="line">&gt; //2.可以按照101公网上面的写法/wx/storage/fetch/xxx这种方式访问，可以主动配置一个servlet，然后将本地的资源文件响应出去----我们写这种方式</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
</blockquote>
<blockquote>
<p>需要使用两个servlet共同处理：&#x2F;admin&#x2F;storage&#x2F;* + &#x2F;wx&#x2F;storage&#x2F;fetch&#x2F;* </p>
<p>前者将文件传入，重新编码，将文件化为storage对象执行存入（数据库url+本地一个路径）、返回storage相应信息</p>
<p>后者将规定地址的本地文件读取，并放入响应返回</p>
</blockquote>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725143339697.png" alt="image-20230725143339697"></p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230725143632101.png" alt="image-20230725143632101"></p>
<ol>
<li><p><strong>请求&#x2F;响应</strong></p>
<p> ​    </p>
</li>
<li><p><strong>实现</strong></p>
<blockquote>
<p>以上两段代码的解读</p>
</blockquote>
<ol>
<li><p><a href="......%5CIdeaProjects%5Cjava52-course-materials%5C03-JavaEE&SpringFramework%5C01-%E4%BB%A3%E7%A0%81%5CDay9_Market%5Csrc%5Cmain%5Cjava%5Ccom%5Ccskaoyan%5Cmarket%5Ccontroller%5CAdminStorageController.java">AdminStorageController.java</a> </p>
<p> 这段代码是实现一个<strong>文件上传功能</strong>的关键逻辑,我来解析一下:</p>
<ol>
<li>获取请求中的文件部分(Part),并获取文件名、大小、类型等信息</li>
<li>生成一个随机key作为文件的名称,存储到数据库和服务器中</li>
<li>获取服务端的域名domain和上传路径uploadPath</li>
<li>执行文件写入到服务器的指定路径</li>
<li>创建一个MarketStorage对象,封装文件信息,插入数据库</li>
<li>构建文件访问URL,需要带上域名,否则默认是localhost</li>
<li>插入数据库后,文件有了id,所以再更新一遍数据库(这一步不是必须的)</li>
<li>构建响应,包含上传后的文件信息</li>
<li>返回响应结果</li>
</ol>
<p> 所以这是一个典型的文件上传实现,包含获取上传文件、写入存储、数据库处理、构建访问URL等所需的关键步骤。</p>
<p> 主要流程是控制上传文件存储位置,数据库记录文件信息,并返回包含访问URL的结果给客户端。</p>
</li>
<li><p><a href="......%5CIdeaProjects%5Cjava52-course-materials%5C03-JavaEE&SpringFramework%5C01-%E4%BB%A3%E7%A0%81%5CDay9_Market%5Csrc%5Cmain%5Cjava%5Ccom%5Ccskaoyan%5Cmarket%5Ccontroller%5CWxStorageFetchController.java">WxStorageFetchController.java</a> </p>
<p> 这段代码实现了<strong>文件下载的功能</strong>,配合之前的文件上传代码,具体工作流程是:</p>
<ol>
<li>从请求URI中提取出key,也就是上传时生成的文件名</li>
<li>从ServletContext中获取上传文件的根目录uploadPath</li>
<li>拼接出文件的完整路径</li>
<li>检查文件是否存在</li>
<li>如果存在,打开文件输入流,写入响应的输出流</li>
<li>在循环中分块读取文件数据,写入输出流发送给客户端</li>
<li>客户端接收到响应数据并保存为文件即实现了下载</li>
<li>如果文件不存在,返回404状态码</li>
</ol>
<p> 主要逻辑是通过key定位文件,获取文件输入流,写入响应输出流。</p>
<p> 配合上传代码,这实现了一个完整的文件上传下载过程,并且文件存储路径抽取到ServletContext中,避免硬编码。</p>
<p> 通过ServletContext共享配置,获取key,然后读取文件写入响应,这是一个非常典型的JavaWeb文件下载实现。</p>
</li>
</ol>
</li>
</ol>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h4 id="创建商品：admin-goods-create"><a href="#创建商品：admin-goods-create" class="headerlink" title="创建商品：admin goods create"></a>创建商品：admin goods create</h4><p>思路</p>
<ol>
<li><p><strong>请求&#x2F;响应</strong></p>
<ul>
<li><p>Post请求，传入值为JSON形式，且比较复杂，故需要用到VO类</p>
<p>  <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726173129016.png" alt="image-20230726173129016"></p>
</li>
</ul>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726173417831.png" alt="image-20230726173417831"></p>
</li>
<li><p><strong>实现</strong></p>
<ul>
<li>VO类<ul>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726173606733.png" alt="image-20230726173606733"></li>
</ul>
</li>
<li>实<ul>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726173631659.png" alt="image-20230726173631659"></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="配置管理❓"><a href="#配置管理❓" class="headerlink" title="配置管理❓"></a>配置管理❓</h3><p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230723191900049.png" alt="image-20230723191900049"></p>
<h4 id="商场配置：admin-config-mall"><a href="#商场配置：admin-config-mall" class="headerlink" title="商场配置：admin config mall"></a>商场配置：admin config mall</h4><p>思路</p>
<ol>
<li><p><strong>请求&#x2F;响应</strong></p>
<ul>
<li>可处理Post的上传和Get的显示</li>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726173749411.png" alt="image-20230726173749411"></li>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726174359607.png" alt="image-20230726174359607"></li>
<li><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726174426629.png" alt="image-20230726174426629"></li>
</ul>
</li>
<li><p><strong>实现</strong></p>
<ul>
<li>阿斯顿</li>
</ul>
</li>
</ol>
<h3 id="用户统计"><a href="#用户统计" class="headerlink" title="用户统计"></a>用户统计</h3><p>统计报表</p>
<p>思路</p>
<p>单独写一个Mapper，用GroupBy</p>
<p>返回一个OK Map(String Object)：包括两个Map：columns和rows，一个里头加两个</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726213834623.png" alt="image-20230726213834623"></p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726214050847.png" alt="image-20230726214050847"></p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726214402616.png" alt="image-20230726214402616"></p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726215202558.png" alt="image-20230726215202558"></p>
<h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="可优化的点："><a href="#可优化的点：" class="headerlink" title="可优化的点："></a>可优化的点：</h3><p>其中的service层调用永久层方法重复步骤可用代理实现</p>
<h3 id="链式反应："><a href="#链式反应：" class="headerlink" title="链式反应："></a>链式反应：</h3><p>按照先后顺序：</p>
<ol>
<li>一般使用一个listener在开始的时候将需要读取的：路径白名单、JDBC或者其他的properties加载进Context域</li>
<li>使用多个Filter（不改名字的话就得在WebXML文件中进行配置）进行在进入Servlet（controller）之前的前置操作：设置编码解码格式、访问请求拦截、登陆权限校验</li>
</ol>
<h3 id="文件加载："><a href="#文件加载：" class="headerlink" title="文件加载："></a>文件加载：</h3><p>无</p>
<h2 id="技巧使用"><a href="#技巧使用" class="headerlink" title="技巧使用"></a>技巧使用</h2><blockquote>
<p>整个数据都是JSON的KEY-Value形式，JaksonUtil也是如此获得数据的</p>
</blockquote>
<h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><ol>
<li><p>Post请求数据在请求体中，一般是JSON形式，需要将其转化为Java对象</p>
<blockquote>
<p>需要先获取请求体String，然后再用JacksonUtil中的parse或者ObjectMapper</p>
</blockquote>
<ol>
<li><p>如果传来的JSON数据条目不多，直接JacksonUtil+类型转换就行</p>
<ol>
<li><p>实例</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726153244250.png" alt="image-20230726153244250"></p>
</li>
</ol>
</li>
<li><p>如果是整体的多级对象考虑使用BO+ObjectMapper</p>
<ol>
<li><p>实例</p>
<ol>
<li><p>BO类：</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726153110874.png" alt="image-20230726153110874"></p>
</li>
<li><p>ObjectMapper使用</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726153119046.png" alt="image-20230726153119046"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Get</p>
<ol>
<li>直接req。Parameter就能得到</li>
</ol>
</li>
</ol>
<h3 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h3><p>使用ResponseUtil + JacksonUtil</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230726153611410.png" alt="image-20230726153611410"></p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><blockquote>
<p>MG生成的domain（有POJOBean类和用于拼接SQLwhere条件的Example类，其中拼接方式有critirial和.or两种）、Mapper（接口，对应resource中有xml文件）、TypeHandler（）</p>
</blockquote>
<ol>
<li><p>使用Mybatis-Generator中生成的基础Mapper，可以实现增删改查（查的话需要Example）</p>
</li>
<li><p>VO、BO、TypeHandler：需要自己构建传入传出对象格式时创建，如果有数据库中没有对应的类型需要自己补充</p>
<blockquote>
<p>Controller使用VO收集请求数据,Service层处理业务,Dao层使用VO持久化,返回BO给Service,Service再封装VO返回Controller。</p>
<hr>
<p>其中TypeHandler可以发挥重要作用,主要用在以下地方:</p>
<ol>
<li><p>数据传输对象VO</p>
<p> 可以使用TypeHandler将VO中的属性类型转换为数据库对应的列类型,用于插入和查询。</p>
</li>
<li><p>参数绑定</p>
<p> 在Mapper接口方法中,TypeHandler可以自动转换入参类型到数据库列类型。</p>
</li>
<li><p>查询结果映射</p>
<p> TypeHandler将数据库查询结果中的列类型,自动映射到VO属性中。</p>
</li>
<li><p>自定义类型支持</p>
<p> 可以使用TypeHandler来支持数据库函数返回的自定义类型。</p>
</li>
</ol>
<p>例如实现一个JsonTypeHandler,支持MySQL 5.7的JSON数据类型:这样就可以在Mapper接口直接使用JsonObject作为参数和返回值。</p>
</blockquote>
</li>
</ol>
<h2 id="StringUtil"><a href="#StringUtil" class="headerlink" title="StringUtil"></a>StringUtil</h2><blockquote>
<p>StringUtil是一个用于字符串操作的工具类,它封装了字符串处理的常用功能,可以简化字符串操作。</p>
</blockquote>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>StringUtil主要是基于Java自身的String类进行的封装,提供了一些常用的字符串校验、转换、格式化等静态方法。</p>
</blockquote>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>StringUtil的常用方法包括:</p>
<ul>
<li>isEmpty&#x2F;isNotEmpty - 判断字符串是否为空</li>
<li>equals&#x2F;equalsIgnoreCase - 字符串比较</li>
<li>concat - 字符串拼接</li>
<li>toUpper&#x2F;toLower - 大小写转换</li>
<li>format - 格式化字符串</li>
<li>getBytes - 字符串转换为字节数组</li>
<li>substring&#x2F;left&#x2F;right - 字符串截取</li>
<li>etc.</li>
</ul>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaCopy <span class="title function_">codeif</span><span class="params">(StringUtil.isEmpty(str)</span>)&#123;</span><br><span class="line">  <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">upper</span> <span class="operator">=</span> StringUtil.toUpper(str);</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>参数为空指针时需要处理异常</li>
<li>避免频繁的字符串拼接操作影响性能</li>
<li>格式化模板语法安全,防止注入攻击</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>代码更简洁,提高开发效率</li>
<li>可重用性高,避免重复开发</li>
<li>封装性好,集中管理字符串操作</li>
<li>可扩展性强,可自定义更多方法</li>
</ul>
<p>所以StringUtil通过封装字符串操作的工具方法,可以节约开发时间,提高代码可读性和可维护性。</p>
<h2 id="JacksonUtil"><a href="#JacksonUtil" class="headerlink" title="JacksonUtil"></a>JacksonUtil</h2><p>Jackson是一个流行的Java JSON解析库，是基于Jackson封装的一个工具类。它简化了JSON与Java对象的互相转换。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>Jackson的核心原理是通过反射获取Java类的结构信息,像字段名、类型等,再根据JSON语法进行转换。通过基于Jackson的轻量级封装，可以减少处理JSON的重复繁琐代码。</p>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>JacksonUtil常见的使用方法有:</p>
<ul>
<li>readValue() - JSON解析为Java对象</li>
<li>writeValueAsString() - Java对象转换为JSON字符串</li>
</ul>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JacksonUtil.readValue(json, User.class); </span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JacksonUtil.writeValueAsString(user);</span><br></pre></td></tr></table></figure>

<p>也可以用于Map, List等集合对象与JSON的转换。</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>JSON字段名和Java属性名需要一致</li>
<li>注解可以控制JSON的生成</li>
<li>需要处理JSON解析异常</li>
<li>优先使用流的方式处理大JSON数据</li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>使用简单,减少大量编码工作</li>
<li>性能高效</li>
<li>自动转换支持广泛类型</li>
<li>支持注解控制序列化</li>
<li>可扩展性强</li>
</ul>
<h2 id="ResponseUtil"><a href="#ResponseUtil" class="headerlink" title="ResponseUtil"></a>ResponseUtil</h2><p>ResponseUtil是处理Web接口响应的一个工具类,它可以用于统一接口响应格式,方便接口与客户端的数据交互。</p>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>ResponseUtil主要基于格式化一个Map来封装响应数据,通常格式如下:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 数据内容 </span></span><br><span class="line">  <span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><p>ResponseUtil提供了一些静态方法用于构建响应:</p>
<ul>
<li>ok() - 构建成功无数据的响应</li>
<li>ok(data) - 构建成功有数据的响应</li>
<li>fail() - 构建失败无数据的响应</li>
<li>fail(data) - 构建失败有数据的响应</li>
</ul>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功无数据</span></span><br><span class="line">ResponseUtil.ok();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功有数据</span></span><br><span class="line">ResponseUtil.ok(user); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败无数据</span></span><br><span class="line">ResponseUtil.fail(<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>code和message要符合系统规范</li>
<li>data不要返回敏感信息</li>
<li>接口响应格式可以根据需要调整</li>
</ul>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>统一接口响应格式和规范</li>
<li>简化接口返回值处理</li>
<li>错误码和信息可配置</li>
<li>鼓励职责单一原则,接口聚焦业务</li>
</ul>
<p>所以ResponseUtil可以简化接口响应处理,提高系统接口质量和开发效率。</p>
<h2 id="PageHelper"><a href="#PageHelper" class="headerlink" title="PageHelper"></a>PageHelper</h2><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>必须</p>
<ol>
<li><p>传两个int值，<code>page</code>和<code>limit</code></p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230730213036249.png" alt="image-20230730213036249"></p>
</li>
<li><p>写在需要实现的查询语句的上一行</p>
<p> <img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230730213123046.png" alt="image-20230730213123046"></p>
</li>
</ol>
</li>
<li><p>不能</p>
</li>
</ol>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>为什么查询时我们不需要把参数传入我们的查询即可使用呢？</p>
<p>肯定是在某个地方设置了参数，然后在查询时可以拿到，那么顺其自然很容易就想到了java的juc包下提供的ThreadLocal</p>
</blockquote>
<p>流程总结：</p>
<ol>
<li>设置分页参数到ThreadLocal中</li>
<li>调用查询，基于插件（拦截器）拦截query方法，从ThreadLocal中获取分页参数，针对不同的数据库类型使用不同的数据库分页方案</li>
<li>根据结果包装返回PageInfo，这里注意的是调用了查询方法返回的List实际上是PageHelper的一个内部实现类Page，Page继承自ArrayList，保存了分页使用的参数</li>
</ol>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="ThreadLocal-有什么用？"><a href="#ThreadLocal-有什么用？" class="headerlink" title="ThreadLocal 有什么用？"></a>ThreadLocal 有什么用？</h5><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>
<p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>
<h5 id="如何使用-ThreadLocal？"><a href="#如何使用-ThreadLocal？" class="headerlink" title="如何使用 ThreadLocal？"></a>如何使用 ThreadLocal？</h5><p>相信看了上面的解释，大家已经搞懂 <code>ThreadLocal</code> 类是个什么东西了。下面简单演示一下如何在项目中实际使用 <code>ThreadLocal</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadLocalExample</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalExample</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(obj, <span class="string">&quot;&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; default Formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won&#x27;t reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果 :</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread Name= 0 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 0 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 1 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 2 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 1 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 3 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 2 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 4 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 3 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 4 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 5 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 5 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 6 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 6 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 7 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 7 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 8 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 9 default Formatter = yyyyMMdd HHmm</span><br><span class="line">Thread Name= 8 formatter = yy-M-d ah:mm</span><br><span class="line">Thread Name= 9 formatter = yy-M-d ah:mm</span><br></pre></td></tr></table></figure>

<p>从输出中可以看出，虽然 <code>Thread-0</code> 已经改变了 <code>formatter</code> 的值，但 <code>Thread-1</code> 默认格式化值与初始化值相同，其他线程也一样。</p>
<p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法<code>withInitial()</code>，将 Supplier 功能接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h5><p>从 <code>Thread</code>类源代码入手。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p><code>ThreadLocal</code>类的<code>set()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>
<p><code>ThreadLocal</code> 数据结构如下图所示：</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgthreadlocal-data-structure.png" alt="ThreadLocal 数据结构">ThreadLocal 数据结构</p>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>
<p><img src="https://typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgthread-local-inner-class.png" alt="ThreadLocal内部类">ThreadLocal内部类</p>
<h5 id="ThreadLocal-内存泄露问题是怎么导致的？"><a href="#ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="# ThreadLocal 内存泄露问题是怎么导致的？"></a><a href="#threadlocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%BC%E8%87%B4%E7%9A%84">#</a> ThreadLocal 内存泄露问题是怎么导致的？</h5><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h4 id="静态方法：startPage："><a href="#静态方法：startPage：" class="headerlink" title="静态方法：startPage："></a>静态方法：startPage：</h4><p>根据分页参数保存了一个Page设置到ThreadLocal中保存起来。</p>
<h4 id="PageIntercepter"><a href="#PageIntercepter" class="headerlink" title="PageIntercepter"></a>PageIntercepter</h4><p>1、注解：@Intercepts，是mybatis提供的插件功能，method &#x3D; “query”说明是针对query方法的插件，简单的可以理解为：这个类可以拦截所有基于mybatis的查询，因为查询接口最后都会调用到query方法。</p>
<blockquote>
<p><code>Mybatis</code>拦截器可以对下面4种对象进行拦截：</p>
<p>• <code>Executor</code>：mybatis的内部执行器，作为调度核心负责调用StatementHandler操作数据库，并把结果集通过ResultSetHandler进行自动映射<br>• <code>StatementHandler</code>：封装了JDBC Statement操作，是sql语法的构建器，负责和数据库进行交互执行sql语句<br>• <code>ParameterHandler</code>：作为处理sql参数设置的对象，主要实现读取参数和对PreparedStatement的参数进行赋值<br>• <code>ResultSetHandler</code>：处理Statement执行完成后返回结果集的接口对象，mybatis通过它把ResultSet集合映射成实体对象</p>
</blockquote>
<p>2、其中代码做了一些是否要分页等判断，我们先姑且不关注，直接关注标记@1的核心代码。ExecutorUtil.pageQuery，这是一个分页查询方法</p>
<h3 id="PageHelper-安全调用"><a href="#PageHelper-安全调用" class="headerlink" title="PageHelper 安全调用"></a><code>PageHelper</code> 安全调用</h3><h4 id="使用-RowBounds-和-PageRowBounds-参数方式是极其安全的"><a href="#使用-RowBounds-和-PageRowBounds-参数方式是极其安全的" class="headerlink" title="使用 RowBounds 和 PageRowBounds 参数方式是极其安全的"></a>使用 <code>RowBounds</code> 和 <code>PageRowBounds</code> 参数方式是极其安全的</h4><h4 id="使用参数方式是极其安全的"><a href="#使用参数方式是极其安全的" class="headerlink" title="使用参数方式是极其安全的"></a>使用参数方式是极其安全的</h4><h4 id="使用-ISelect-接口调用是极其安全的"><a href="#使用-ISelect-接口调用是极其安全的" class="headerlink" title="使用 ISelect 接口调用是极其安全的"></a>使用 ISelect 接口调用是极其安全的</h4><p>ISelect 接口方式除了可以保证安全外，还特别实现了将查询转换为单纯的 count 查询方式，这个方法可以将任意的查询方法，变成一个 <code>select count(*)</code> 的查询方法。</p>
<h4 id="什么时候会导致不安全的分页？"><a href="#什么时候会导致不安全的分页？" class="headerlink" title="什么时候会导致不安全的分页？"></a>什么时候会导致不安全的分页？</h4><p><code>PageHelper</code> 方法使用了静态的 <code>ThreadLocal</code> 参数，分页参数和线程是绑定的。</p>
<p>只要你可以保证在 <code>PageHelper</code> 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 <code>PageHelper</code> 在 <code>finally</code> 代码段中自动清除了 <code>ThreadLocal</code> 存储的对象。</p>
<p>如果代码在进入 <code>Executor</code> 前发生异常，就会导致线程不可用，这属于人为的 Bug（例如接口方法和 XML 中的不匹配，导致找不到 <code>MappedStatement</code> 时）， 这种情况由于线程不可用，也不会导致 <code>ThreadLocal</code> 参数被错误的使用。</p>
<p>但是如果你写出下面这样的代码，就是不安全的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;Country&gt; list;</span><br><span class="line"><span class="keyword">if</span>(param1 != <span class="literal">null</span>)&#123;</span><br><span class="line">    list = countryMapper.selectIf(param1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Country&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。</p>
<p>上面这个代码，应该写成下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Country&gt; list;</span><br><span class="line"><span class="keyword">if</span>(param1 != <span class="literal">null</span>)&#123;</span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    list = countryMapper.selectIf(param1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Country&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法就能保证安全。</p>
<p>如果你对此不放心，你可以手动清理 <code>ThreadLocal</code> 存储的分页参数，可以像下面这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Country&gt; list;</span><br><span class="line"><span class="keyword">if</span>(param1 != <span class="literal">null</span>)&#123;</span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        list = countryMapper.selectAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        PageHelper.clearPage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Country&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么写很不好看，而且没有必要。</p>
<h2 id="Mybatis-Generator"><a href="#Mybatis-Generator" class="headerlink" title="Mybatis-Generator"></a>Mybatis-Generator</h2><h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><p>生成的代码可能有问题，如果出现SyntaxException  → 一定要看控制台里的sql → 检查你的sql语句</p>
<h3 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h3><blockquote>
<ol>
<li>MyBatis之所以能解决MySQL字段和Java属性之间的匹配，全都依赖于<code>org.apache.ibatis.type.BaseTypeHandler&lt;T&gt;</code>抽象类，在该类中定义了3个获取结果的方法、1个更新的方法和4个抽象方法，我们可以自定义该抽象类来实现这个4个抽象方法进行Java类的属性和表字段的映射，可以做一些相关的处理。</li>
<li>MyBatis在<code>org.apache.ibatis.type</code>包中定义了常用的字段映射<code>Handler</code>，并且在服务启动的时候会在<code>TypeHandlerRegistry</code>构造方法中将其注册到一个Map中，而<code>TypeHandlerRegistry</code>是在MyBatis的核心类<code>Configuration</code>中进行的实例化</li>
<li>自定义的<code>Handler</code>可以全局通用，不受限于某一个字段或某一个Java类</li>
<li>在生成Mapper时使用<code>&lt;columnOverride&gt;</code>重写<code>column</code>声明，然后需要指定<code>jdbcType</code>和<code>typeHandler</code></li>
</ol>
</blockquote>
<h1 id="项目二"><a href="#项目二" class="headerlink" title="项目二"></a>项目二</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><p>小程序没有跨域问题</p>
</li>
<li><p>小程序没有cookie</p>
</li>
<li><p>小程序不用鉴权</p>
<ol>
<li><p>需要把项目1的后端和小程序的后端结合，因为前端访问后端的端口都是8083，但是shiro认证的功能要报错：</p>
<p> <img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807164230631.png" alt="image-20230807164230631"></p>
</li>
</ol>
</li>
</ol>
<p>mybatis中的xxxExample中criteria为什么有连续.andxxx.andxxx.or的写法？这是Java8中的Stream吗？</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>项目一中：</p>
<ol>
<li>AspectJ实现日志</li>
<li>用户管理——授权</li>
</ol>
<p><img src="/!%5B%5D(https:/typora-picgo-zyx.oss-cn-beijing.aliyuncs.com/img/typora_imgimage-20230807165001277.png" alt="image-20230807165001277"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zhao Yi Xiao</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




</body>
</html>
